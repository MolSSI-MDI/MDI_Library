'@':
  summary: "Manage operations related to the current node."
  category: 1
  commands:
  - <@:
      count: MDI_NAME_LENGTH
      datatype: MDI_CHAR
      description: Receive current node name.
      doc: The engine sends the driver a string that corresponds to the name of its
        current node.
      examples:
        python: |
          import mdi

          # connect to the engine
          mdi_engine = mdi.MDI_Accept_Communicator()

          # send the "<@" command to the engine to get the current node
          mdi.MDI_Send_Command("<@", mdi_engine) 

          # receive the name of the current node
          node_name = mdi.MDI_Recv(mdi.MDI_NAME_LENGTH, mdi.MDI_CHAR, mdi_engine)
        cpp: |
          #include "mdi.h"

          // connect to the engine
          MDI_Comm mdi_engine = MDI_Accept_Communicator();

          // create a buffer to hold the name of the current node
          char* node_name = new char[MDI_NAME_LENGTH];

          // send the "<@" command to the engine to get the current node
          MDI_Send_Command("<@", mdi_engine);

          // receive the name of the current node
          MDI_Recv(node_name, MDI_NAME_LENGTH, MDI_CHAR, mdi_engine);
  - '@':
      description: Go to the next node.
      doc: The engine proceeds to the next node. Typically not supported at the `@DEFAULT` node.
      examples:
        python: |
          import mdi

          # connect to the engine
          mdi_engine = mdi.MDI_Accept_Communicator()

          # send the "@INIT_MD" command to the engine (so we are not at default node)
          mdi.MDI_Send_Command("@INIT_MD", mdi_engine)

          # send the engine to the next node.
          mdi.MDI_Send_Command("@", mdi_engine)
        cpp: |
          #include "mdi.h"

          // connect to the engine
          MDI_Comm mdi_engine = MDI_Accept_Communicator();

          // send the "@INIT_MD" command to the engine (so we are not at default node)
          MDI_Send_Command("@INIT_MD", mdi_engine);

          // send the engine to the next node
          MDI_Send_Command("@", mdi_engine);  
'@INIT_MC':
  summary: "Initialize a Monte Carlo simulation."
  category: 1
  tags:
    - Monte Carlo
  commands:
    - '@INIT_MC':
        description: "Go to @INIT_MC node."
        doc: |
          The engine performs any initialization operations that are necessary before a Monte Carlo simulation can be performed, 
          proceeding to the `@INIT_MC` node
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # initialize a Monte Carlo simulation
            mdi.MDI_Send_Command("@INIT_MC", mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // initialize a Monte Carlo simulation
            MDI_Send_Command("@INIT_MC", mdi_engine);
'@INIT_MD':
  category: 1
  summary: "Initialize a Molecular Dynamics simulation."
  tags:
    - Molecular Dynamics
  commands:
    - '@INIT_MD':
        description: "Go to @INIT_MD node."
        admonition:
          type: caution
          title: "Note"
          content: "This command may change the engine's atomic coordinates under certain circumstances, such as if the SHAKE algorithm is used."
        doc: |
          The engine performs any initialization operations that are necessary before a molecular dynamics simulation can be performed, 
          proceeding to the `@INIT_MD` node
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # initialize a Molecular Dynamics simulation
            mdi.MDI_Send_Command("@INIT_MD", mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // initialize a Molecular Dynamics simulation
            MDI_Send_Command(">@INIT_MC", mdi_engine);
'@INIT_OPTG':
  category: 1
  summary: "Initialize a geometry optimization."
  commands:
    - '@INIT_OPTG':
        description: "Go to @INIT_OPTG node."
        admonition:
          type: caution
          title: "Note"
          content: "This command may change the engine's atomic coordinates under certain circumstances, such as if the SHAKE algorithm is used."
        doc: |
          The engine performs any initialization operations that are necessary before a geometry optimization can be performed, 
          proceeding to the @INIT_OPTG node.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # initialize a geometry optimization.
            mdi.MDI_Send_Command("@INIT_OPTG", mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // initialize a geometry optimization.
            MDI_Send_Command("@INIT_OPTG", mdi_engine);
'@DEFAULT':
  category: 1
  summary: "Operations related to the @DEFAULT node. The @DEFAULT node is the node that the engine goes to when launched."
  commands:
    - '@DEFAULT':
        description: ""
        doc: >
          This is the node that the engine goes to when launched.
          Typically `@DEFAULT` is called if the engine has been sent to a different node and the driver wants to return to the default node.
          If not already at the @DEFAULT node, the engine exits whatever simulation (i.e. MD, OPTG, etc.) it is performing 
          (possibly after completing an unfinished time step or geometry optimization step) and returns to the @DEFAULT node.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # initialize a Monte Carlo simulation
            mdi.MDI_Send_Command("@DEFAULT", mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // initialize a Monte Carlo simulation
            MDI_Send_Command(">@DEFAULT", mdi_engine);
'@FORCES':
  category: 1
  summary: "Go to point in code after forces have been calculated."
  commands:
    - '@FORCES':
        description: "Go to @FORCES node."
        doc: |
          The engine proceeds to the next @FORCES node. 
          This node occurs after all contributions to the atomic forces have been calculated.
          This command is not valid at the [@DEFAULT](#@DEFAULT-target) node.
          One would typically proceed to the @FORCES node after initializing a simulation 
          (e.g. [@INIT_MD](#@INIT_MD), [@INIT_MC](#@INIT_MC), or [@INIT_OPTG](#@INIT_OPTG)).
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # first initialize a simulation
            mdi.MDI_Send_Command("@INIT_MD", mdi_engine)

            # go to forces node
            mdi.MDI_Send_Command("@FORCES", mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // first initialize a simulation
            MDI_Send_Command("@INIT_MD", mdi_engine);

            // go to forces node.
            MDI_Send_Command("@FORCES", mdi_engine);
'@PRE-FORCES':
  category: 1
  summary: "Go to point in code where forces have been partially calcualted."
  commands:
    - '@FORCES':
        description: "Go to @PRE-FORCES node."
        doc: |
          The engine proceeds to the next @PRE-FORCES node. 
          This node occurs after calculating all contributions to the atomic forces, except those associated with a constraint algorithm like SHAKE or RATTLE.
          This command is not valid at the [@DEFAULT](#@DEFAULT) node.
          One would typically proceed to the @FORCES node after initializing a simulation 
          (e.g. [@INIT_MD](#@INIT_MD), [@INIT_MC](#@INIT_MC), or [@INIT_OPTG](#@INIT_OPTG)).
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # first initialize a simulation
            mdi.MDI_Send_Command("@INIT_MD", mdi_engine)

            # go to forces node
            mdi.MDI_Send_Command("@PRE-FORCES", mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // first initialize a simulation
            MDI_Send_Command("@INIT_MD", mdi_engine);

            // go to forces node.
            MDI_Send_Command("@PRE-FORCES", mdi_engine);
'@COORDS':
  category: 1
  summary: "Go to point in code after atomic coordinates have been updated."
  commands:
    - '@COORDS':
        description: "Go to @COORDS node."
        doc: |
          The engine proceeds to the next @PRE-FORCES node. 
          The `@COORDS` node occurs after updating the atomic coordinates.
          This command is not valid at the [@DEFAULT](#@DEFAULT) node.
          One would typically proceed to the @FORCES node after initializing a simulation 
          (e.g. [@INIT_MD](#@INIT_MD), [@INIT_MC](#@INIT_MC), or [@INIT_OPTG](#@INIT_OPTG)).
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # first initialize a simulation
            mdi.MDI_Send_Command("@INIT_MD", mdi_engine)

            # go to forces node
            mdi.MDI_Send_Command("@COORDS", mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // first initialize a simulation
            MDI_Send_Command("@INIT_MD", mdi_engine);

            // go to forces node.
            MDI_Send_Command("@COORDS", mdi_engine);
'COORDS':
  category: 1
  summary: "Go to point in code after atomic coordinates have been updated."
  commands:
    - '@COORDS':
        description: "Go to @PRE-FORCES node."
        doc: |
          The engine proceeds to the next @PRE-FORCES node. 
          After calculating all contributions to the atomic forces, except those associated with a constraint algorithm like SHAKE or RATTLE.
          This command is not valid at the [@DEFAULT](#@DEFAULT) node.
          One would typically proceed to the @FORCES node after initializing a simulation 
          (e.g. [@INIT_MD](#@INIT_MD), [@INIT_MC](#@INIT_MC), or [@INIT_OPTG](#@INIT_OPTG)).
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # first initialize a simulation
            mdi.MDI_Send_Command("@INIT_MD", mdi_engine)

            # go to forces node
            mdi.MDI_Send_Command("@PRE-FORCES", mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // first initialize a simulation
            MDI_Send_Command("@INIT_MD", mdi_engine);

            // go to forces node.
            MDI_Send_Command("@PRE-FORCES", mdi_engine);
EXIT:
  category: 1
  summary: "Exit the engine."
  commands:
    - EXIT:
        description: "End engine execution."
        doc: >
          The engine terminates and can no longer be sent commands.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # perform some operations

            # exit the engine
            mdi.MDI_Send_Command("EXIT", mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // perform some operations

            // exit the engine
            MDI_Send_Command("EXIT", mdi_engine);
CDENSITY:
  category: 2
  summary: "Exchange Cartesian coordinates for grid points."
  tags:
      - Quantum Mechanics
  commands:
  - <CDENSITY:
      count: 3 * NDENSITY
      datatype: MDI_DOUBLE
      units: Bohr
      description: Receive Cartesian coordinates for grid points.
      doc: >
        The engine sends the Cartesian coordinates of a set of grid points. 
        This command is intended to be used in conjuction with the [<NDENSITY](#NDENSITY) and [<DENSITY](#DENSITY) commands; 
        these three commands enable a driver to acquire the electronic density distribution of an engine in a grid representation. 
        See the [<DENSITY](#DENSITY) command for more details.
      examples:
        python: |
          import mdi

          # connect to the engine
          mdi_engine = mdi.MDI_Accept_Communicator()

          # retrieve the number of grid points
          mdi.MDI_Send_Command("<NDENSITY", mdi_engine)
          ndensity = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)

          # receive the Cartesian coordinates of the grid points
          mdi.MDI_Send_Command("<CDENSITY", mdi_engine)
          cdensity = mdi.MDI_Recv(3*ndensity, mdi.MDI_DOUBLE, mdi_engine)
        python (numpy): |
          import mdi
          import numpy as np

          # connect to the engine
          mdi_engine = mdi.MDI_Accept_Communicator()

          # retrieve the number of grid points
          mdi.MDI_Send_Command("<NDENSITY", mdi_engine)
          ndensity = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)

          # create a buffer to hold the Cartesian coordinates of the grid points
          cdensity = np.zeros(3*ndensity, dtype=float)

          # receive the Cartesian coordinates of the grid points
          mdi.MDI_Send_Command("<CDENSITY", mdi_engine)
          mdi.MDI_Recv(3*ndensity, mdi.MDI_DOUBLE, mdi_engine, buf=cdensity)
        cpp: |
          #include "mdi.h"
          #include <vector>

          // connect to the engine
          MDI_Comm mdi_engine = MDI_Accept_Communicator();

          // receive the Cartesian coordinates of the grid points
          int ndensity;
          MDI_Send_Command("<NDENSITY", mdi_engine);
          MDI_Recv(&ndensity, 1, MDI_INT, mdi_engine);
          
          // create a vector to hold the Cartesian coordinates of the grid points
          std::vector<double> cdensity(3*ndensity);

          // receive the Cartesian coordinates of the grid points
          MDI_Send_Command("<CDENSITY", mdi_engine);
          MDI_Recv(cdensity.data(), 3*ndensity, MDI_DOUBLE, mdi_engine);
CELL:
  category: 2
  summary: "Exchange cell vectors for simulation boxes."
  commands:
    - "<CELL":
        description: "Receive cell vectors."
        datatype: "MDI_DOUBLE"
        count: 9
        units: Bohr
        format: "The first 3 values correspond to the x, y, and z values, respectively, of the first cell vector. The next 3 values correspond to the x, y, and z values, respectively, of the second cell vector. The next 3 values correspond to the x, y, and z values, respectively, of the third cell vector."
        doc: "The engine sends a set of cell vectors to the driver."
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the cell vectors from the engine
            mdi.MDI_Send_Command("<CELL", mdi_engine)
            cell = mdi.MDI_Recv(9, mdi.MDI_DOUBLE, mdi_engine) 
          python (numpy): |
            import mdi
            import numpy as np

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # create a buffer to hold the cell vectors
            cell = np.zeros(9, dtype=float)

            # receive the cell vectors from the engine
            mdi.MDI_Send_Command("<CELL", mdi_engine)
            mdi.MDI_Recv(9, mdi.MDI_DOUBLE, mdi_engine, buf=cell)
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // make a buffer to hold the cell vectors 
            std::vector<double> cell(9);

            // receive the cell vectors from the engine
            MDI_Send_Command("<CELL", mdi_engine);
            MDI_Recv(cell.data(), 9, MDI_DOUBLE, mdi_engine);
    - ">CELL":
        description: "Send cell vectors to resize simulation cell."
        datatype: "MDI_DOUBLE"
        count: 9
        units: Bohr
        doc: "The driver sends a set of cell vectors to the engine, which resizes its simulation cell to the dimensions specified by the cell vectors."
        format: "The first 3 values correspond to the x, y, and z values, respectively, of the first cell vector. The next 3 values correspond to the x, y, and z values, respectively, of the second cell vector. The next 3 values correspond to the x, y, and z values, respectively, of the third cell vector."
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # create a list of cell vectors
            cell = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]

            # send the cell vectors to the engine
            mdi.MDI_Send_Command(">CELL", mdi_engine)
            mdi.MDI_Send(cell, 9, mdi.MDI_DOUBLE, mdi_engine)
          python (numpy): |
            import mdi
            import numpy as np

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # create an array of cell vectors
            cell = np.array([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], dtype=float)

            # send the cell vectors to the engine
            mdi.MDI_Send_Command(">CELL", mdi_engine)
            mdi.MDI_Send(cell, 9, mdi.MDI_DOUBLE, mdi_engine)
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a vector of cell vectors
            std::vector<double> cell = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0};
            
            // send the cell vectors to the engine
            MDI_Send_Command(">CELL", mdi_engine);
            MDI_Send(cell.data(), 9, MDI_DOUBLE, mdi_engine);
CELL_DISPL:
  category: 2
  summary: "Exchange cell displacement vectors for simulation boxes."
  commands:
    - '>CELL_DISPL':
        count: 3
        datatype: MDI_DOUBLE
        units: Bohr
        description: Send cell displacement vector to adjust simulation cell origin.
        doc: The driver sends a displacement vector to the engine, which adjusts the origin
          of its simulation cell to the value of the displacement vector.
        examples:
          cpp: '#include "mdi.h"

            #include <vector>


            // connect to the engine

            MDI_Comm mdi_engine = MDI_Accept_Communicator();


            // create an array of cell displacement values

            std::vector<double> cell_displ = {0.0, 1.0, 1.0};


            // send the cell displacement values to the engine

            MDI_Send_Command(">CELL_DISPL", mdi_engine);

            MDI_Send(cell_displ.data(), 3, MDI_DOUBLE, mdi_engine);

            '
          python: 'import mdi


            # connect to the engine

            mdi_engine = mdi.MDI_Accept_Communicator()


            # create a list of displacement values

            cell_displ = [0.0, 1.0, 1.0]


            # send the cell displacement values to the engine

            mdi.MDI_Send_Command(">CELL_DISPL", mdi_engine)

            mdi.MDI_Send(cell_displ, 3, mdi.MDI_DOUBLE, mdi_engine)

            '
          python (numpy): 'import mdi

            import numpy as np


            # connect to the engine

            mdi_engine = mdi.MDI_Accept_Communicator()


            # create an array of cell displacement values

            cell_displ = np.array([0.0, 1.0, 1.0], dtype=float)


            # send the cell displacement values to the engine

            mdi.MDI_Send_Command(">CELL_DISPL", mdi_engine)

            mdi.MDI_Send(cell_displ, 3, mdi.MDI_DOUBLE, mdi_engine)

            '
        format: The 3 values correspond to the x, y, and z values, respectively, of the
          simulation cell displacement vector.
    - <CELL_DISPL:
        count: 3
        datatype: MDI_DOUBLE
        units: Bohr
        description: Retrieve the cell displacement vector.
        doc: The engine sends the displacement vector of the origin of its simulation
          cell to the driver.
        examples:
          cpp: '#include "mdi.h"

            #include <vector>


            // connect to the engine

            MDI_Comm mdi_engine = MDI_Accept_Communicator();


            // create a buffer to hold the cell displacement values

            std::vector<double> cell_displ(3);


            // receive the cell displacement values from the engine

            MDI_Send_Command("<CELL_DISPL", mdi_engine);

            MDI_Recv(cell_displ.data(), 3, MDI_DOUBLE, mdi_engine);

            '
          python: "import mdi\n\n# connect to the engine\nmdi_engine = mdi.MDI_Accept_Communicator()\n\
            \n# receive the cell displacement values from the engine\nmdi.MDI_Send_Command(\"\
            <CELL_DISPL\", mdi_engine)\ncell_displ = mdi.MDI_Recv(3, mdi.MDI_DOUBLE, mdi_engine)\
            \ \n"
          python (numpy): "import mdi\nimport numpy as np\n\n# connect to the engine\n\
            mdi_engine = mdi.MDI_Accept_Communicator()\n\n# create a buffer to hold the\
            \ cell displacement values\ncell_displ = np.zeros(3, dtype=float)\n\n# receive\
            \ the cell displacement values from the engine\nmdi.MDI_Send_Command(\"<CELL_DISPL\"\
            , mdi_engine)\nmdi.MDI_Recv(3, mdi.MDI_DOUBLE, mdi_engine, buf=cell_displ)\
            \ \n"
        format: The 3 values correspond to the x, y, and z values, respectively, of the
          simulation cell displacement vector.
CHARGES:
  category: 2
  summary: "Exchange atomic charge information."
  commands:
    - '>CHARGES':
        count: NATOMS
        datatype: MDI_DOUBLE
        units: elementary charge ({math}`e`)
        description: Send atomic charges.
        doc: The driver sends a set of atomic charges to the engine, which replaces its
          atomic charges with those sent by the driver.
        examples:
          cpp: '#include "mdi.h"

            #include <vector>


            // connect to the engine

            MDI_Comm mdi_engine = MDI_Accept_Communicator();


            // retrieve the number of atoms

            int natoms;

            MDI_Send_Command("<NATOMS", mdi_engine);

            MDI_Recv(&natoms, 1, MDI_INT, mdi_engine);


            // create an vector of atomic charges

            std::vector<double> charges(natoms);


            // fill the array with charges.


            // send the atomic charges to the engine

            MDI_Send_Command(">CHARGES", mdi_engine);

            MDI_Send(charges.data(), natoms, MDI_DOUBLE, mdi_engine);

            '
          python: 'import mdi

            import numpy as np


            # connect to the engine

            mdi_engine = mdi.MDI_Accept_Communicator()


            # retrieve the number of atoms

            mdi.MDI_Send_Command("<NATOMS", mdi_engine)

            natoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)


            # create a list of atomic charges using

            # method appropriate for your use case.

            charges = # some array of atomic charges


            # send the atomic charges to the engine

            mdi.MDI_Send_Command(">CHARGES", mdi_engine)

            mdi.MDI_Send(charges, natoms, mdi.MDI_DOUBLE, mdi_engine)

            '
          python (numpy): 'import mdi

            import numpy as np


            # connect to the engine

            mdi_engine = mdi.MDI_Accept_Communicator()


            # retrieve the number of atoms

            mdi.MDI_Send_Command("<NATOMS", mdi_engine)

            natoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)


            # create an array of atomic charges using

            # method appropriate for your use case.

            # Zeros shown here for example.

            charges = np.zeros(natoms, dtype=float)


            # send the atomic charges to the engine

            mdi.MDI_Send_Command(">CHARGES", mdi_engine)

            mdi.MDI_Send(charges, natoms, mdi.MDI_DOUBLE, mdi_engine)

            '
        format: Sequentially ascending order of atomic index
    - <CHARGES:
        count: NATOMS
        datatype: MDI_DOUBLE
        description: Receive atomic charges.
        units: elementary charge ({math}`e`)
        doc: The engine sends a set of atomic charges to the driver.
        examples:
          cpp: '#include "mdi.h"

            #include <vector>


            // connect to the engine

            MDI_Comm mdi_engine = MDI_Accept_Communicator();


            // retrieve the number of atoms

            int natoms;

            MDI_Send_Command("<NATOMS", mdi_engine);

            MDI_Recv(&natoms, 1, MDI_INT, mdi_engine);


            // create a vector to hold the atomic charges

            std::vector<double> charges(natoms);


            // receive the atomic charges from the engine

            MDI_Send_Command("<CHARGES", mdi_engine);

            MDI_Recv(charges.data(), natoms, MDI_DOUBLE, mdi_engine);

            '
          python: "import mdi\nimport numpy as np\n\n# connect to the engine\nmdi_engine\
            \ = mdi.MDI_Accept_Communicator()\n\n# retrieve the number of atoms\nmdi.MDI_Send_Command(\"\
            <NATOMS\", mdi_engine)\nnatoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)\n\
            \n# receive the atomic charges from the engine\nmdi.MDI_Send_Command(\"<CHARGES\"\
            , mdi_engine)\ncharges = mdi.MDI_Recv(natoms, mdi.MDI_DOUBLE, mdi_engine)\
            \ \n"
          python (numpy): "import mdi\nimport numpy as np\n\n# connect to the engine\n\
            mdi_engine = mdi.MDI_Accept_Communicator()\n\n# retrieve the number of atoms\n\
            mdi.MDI_Send_Command(\"<NATOMS\", mdi_engine)\nnatoms = mdi.MDI_Recv(1, mdi.MDI_INT,\
            \ mdi_engine)\n\n# create a buffer to hold the atomic charges\ncharges = np.zeros(natoms,\
            \ dtype=float)\n\n# receive the atomic charges from the engine\nmdi.MDI_Send_Command(\"\
            <CHARGES\", mdi_engine)\nmdi.MDI_Recv(natoms, mdi.MDI_DOUBLE, mdi_engine,\
            \ buf=charges) \n"
        format: Sequentially ascending order of atomic index
CLATTICE:
  category: 2
  summary: "Send lattice coordinates."
  tags:
    - Quantum Mechanics
    - Gas Phase Quantum Mechanics
  commands:
    - '>CLATTICE':
        count: 3 * NLATTICE
        datatype: MDI_DOUBLE
        units: Bohr
        description: Send lattice coordinates.
        doc: |
          This command, along with the [>NLATTICE](NLATTICE) and [>LATTICE](LATTICE)
          commands, allows the driver to assign a lattice of point charges to an engine,
          which incorporates the effects of these charges in all further calculations.
          After sending this command, the driver sends the coordinates of each of
          the point charges to the engine.
          Prior to sending this command, the driver must have set the number of point charges using the [>NLATTICE](NLATTICE)
          command.
          
          This command is primarily intended for use with gas-phase quantum mechanics codes. 
          For an alternative command that is more appropriate for plane
          wave quantum mechanics codes, see the [>POTENTIAL](POTENTIAL) command.
        examples:
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // get lattice information
            std::vector<double> lattice; // some vector of lattice charges

            std::vector<double> clattice; // some vector of lattice charge coordinates

            int nlattice = lattice.size();

            // send the number of lattice points to the engine
            MDI_Send_Command(">NLATTICE", mdi_engine);
            MDI_Send(nlattice, 1, MDI_INT, mdi_engine);


            // send the lattice coordinates to the engine
            MDI_Send_Command(">CLATTICE", mdi_engine);
            MDI_Send(clattice, 3*nlattice, MDI_DOUBLE, mdi_engine);


            // send the lattice charges to the engine
            MDI_Send_Command(">LATTICE", mdi_engine);
            MDI_Send(clattice, nlattice, MDI_DOUBLE, mdi_engine);

          python: |
            import mdi
            # connect to the engine

            mdi_engine = mdi.MDI_Accept_Communicator()

            # get lattice information
            lattice = # some array of lattice charges
            clattice = # some array of lattice charge coordintaes
            nlattice = len(lattice)

            # send the number of lattice points to the engine
            mdi.MDI_Send_Command(">NLATTICE", mdi_engine)
            mdi.MDI_Send(nlattice, 1, mdi.MDI_INT, mdi_engine)


            # send the lattice coordinates to the engine
            mdi.MDI_Send_Command(">CLATTICE", mdi_engine)
            mdi.MDI_Send(clattice, 3*nlattice, mdi.MDI_DOUBLE, mdi_engine)


            # send the lattice charges to the engine
            mdi.MDI_Send_Command(">LATTICE", mdi_engine)

            mdi.MDI_Send(clattice, nlattice, mdi.MDI_DOUBLE, mdi_engine)

        format: Sequentially ascending order of lattice charge index, with the coordinates
          for each individual lattice charge being provided in xyz order.
COORDS:
  category: 2
  summary: "Exchange atomic coordinate information."
  commands:
    - '>COORDS':
        count: 3 * NATOMS
        datatype: MDI_DOUBLE
        units: Bohr
        description: Send atomic coordinates.
        doc: 'The driver sends a set of atomic coordinates to the engine,  which replaces
          its atomic coordinates with those sent by the driver.

          '
        examples:
          cpp: "#include \"mdi.h\"\n#include <vector>\n\n// connect to the engine\nMDI_Comm\
            \ mdi_engine = MDI_Accept_Communicator();\n\n// create a vector of atomic\
            \ coordinates \n\n// send the atomic coordinates to the engine \nMDI_Send_Command(\"\
            >COORDS\", mdi_engine);\nMDI_Send(coords.data(), 3*natoms, MDI_DOUBLE, mdi_engine);\n"
          python: "import mdi\n\n# connect to the engine\nmdi_engine = mdi.MDI_Accept_Communicator()\n\
            \n# create an array of atomic coordinates\n\n# send the atomic coordinates\
            \ to the engine \nmdi.MDI_Send_Command(\">COORDS\", mdi_engine)\nmdi.MDI_Send(coords,\
            \ 3*natoms, mdi.MDI_DOUBLE, mdi_engine)  \n"
        format: Sequentially ascending order of atomic index, with the coordinates for
          each individual atom being provided in xyz order.
    - <COORDS:
        category: 2
        count: 3 * NATOMS
        datatype: MDI_DOUBLE
        units: Bohr
        description: Receive atomic coordinates.
        doc: 'The engine sends a set of atomic coordinates to the driver.

          '
        examples:
          cpp: '#include "mdi.h"

            #include <vector>


            // connect to the engine

            MDI_Comm mdi_engine = MDI_Accept_Communicator();


            // create a buffer to hold the atomic coordinates

            std::vector<double> coords(3*natoms);


            // receive the atomic coordinates from the engine

            MDI_Send_Command("<COORDS", mdi_engine);

            MDI_Recv(coords.data(), 3*natoms, MDI_DOUBLE, mdi_engine);

            '
          python: 'import mdi


            # connect to the engine

            mdi_engine = mdi.MDI_Accept_Communicator()


            # receive the atomic coordinates from the engine

            mdi.MDI_Send_Command("<COORDS", mdi_engine)

            coords = mdi.MDI_Recv(3*natoms, mdi.MDI_DOUBLE, mdi_engine)

            '
          python (numpy): "import mdi\nimport numpy as np\n\n# connect to the engine\n\
            mdi_engine = mdi.MDI_Accept_Communicator()\n\n# create a buffer to hold the\
            \ atomic coordinates\ncoords = np.zeros(3*natoms, dtype=float)\n\n# receive\
            \ the atomic coordinates from the engine\nmdi.MDI_Send_Command(\"<COORDS\"\
            , mdi_engine)\nmdi.MDI_Recv(3*natoms, mdi.MDI_DOUBLE, mdi_engine, buf=coords)\
            \ \n"
        format: Sequentially ascending order of atomic index, with the coordinates for
          each individual atom being provided in xyz order.
CPOTENTIAL:
  category: 2
  summary: "Send Cartesian coordinates of grid points."
  commands:
    - '>CPOTENTIAL':
        category: 2
        count: 3 * NPOTENTIAL
        datatype: MDI_DOUBLE
        units: Bohr
        description: Send Cartesian coordinates of grid points.
        doc: 'The driver sends the Cartesian coordinates of a set of grid points.  This
          command is intended to be used in conjuction with the [>NPOTENTIAL](NPOTENTIAL)
          and [>POTENTIAL](POTENTIAL) commands;  these three commands enable a driver
          to set an external potential that is incorporated into a subsequent scf_command
          command.  See the [>POTENTIAL](POTENTIAL) command for more details.

          Before sending this command, the driver must have first sent the number of grid
          points used to represent the potential via the >NPOTENTIAL command.  It is also
          necessary that the driver send the values of the grid points via the >CPOTENTIAL
          command prior to any subsequent scf_command command.

          '
        examples:
          cpp: '#include "mdi.h"

            #include <vector>


            // connect to the engine

            MDI_Comm mdi_engine = MDI_Accept_Communicator();


            // retrieve the number of atoms

            int natoms;

            MDI_Send_Command("<NATOMS", mdi_engine);

            MDI_Recv(&natoms, 1, MDI_INT, mdi_engine);


            // create an vector of atomic core potentials

            std::vector<double>

            '
          python: 'import mdi

            import numpy as np


            # connect to the engine

            mdi_engine = mdi.MDI_Acmmunicator()


            # retrieve the number of atoms

            mdi.MDI_Send_Command("<NATOMS", mdi_engine)

            natoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)


            # create a list of atomic core potentials using

            # method appropriate for your use case.

            cpotential = # some array of atomic core potentials


            # send the atomic core potentials to the engine

            mdi.MDI_Send_Command(">CPOTENTIAL", mdi_engine)

            mdi.MDI_Send(cpotential, natoms, mdi.MDI_DOUBLE, mdi_engine)

            '
          python (numpy): 'import mdi

            import numpy as np


            # connect to the engine

            mdi_engine = mdi.MDI_Accept_Communicator()


            # retrieve the number of atoms

            mdi.MDI_Send_Command("<NATOMS", mdi_engine)

            natoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)


            # create an array of atomic core potentials using

            # method appropriate for your use case.

            # Zeros shown here for example.

            cpotential = np.zeros(natoms, dtype=float)


            # send the atomic core potentials to the engine

            mdi.MDI_Send_Command(">CPOTENTIAL", mdi_engine)

            mdi.MDI_Send(cpotential, natoms, mdi.MDI_DOUBLE, mdi_engine)

            '
FORCES:
  category: 2
  summary: "Exchange atomic forces information."
  commands:
    - '>FORCES':
        count: 3 * NATOMS
        datatype: MDI_DOUBLE
        description: Send atomic forces.
        units: Hartree/Bohr
        doc: 'The driver sends a set of atomic forces to the engine,  which replaces its
          internal forces with the forces sent by the driver.

          '
        examples:
          cpp: "#include \"mdi.h\"\n#include <vector>\n\n// connect to the engine\nMDI_Comm\
            \ mdi_engine = MDI_Accept_Communicator();\n\n// create a vector of atomic\
            \ forces \n\n// send the atomic forces to the engine \nMDI_Send_Command(\"\
            >FORCES\", mdi_engine);\nMDI_Send(forces.data(), 3*natoms, MDI_DOUBLE, mdi_engine);\n"
          python: "import mdi\n\n# connect to the engine\nmdi_engine = mdi.MDI_Accept_Communicator()\n\
            \n# create an array of atomic forces\n\n# send the atomic forces to the engine\
            \ \nmdi.MDI_Send_Command(\">FORCES\", mdi_engine)\nmdi.MDI_Send(forces, 3*natoms,\
            \ mdi.MDI_DOUBLE, mdi_engine)  \n"
          python (numpy): 'import mdi

            import numpy as np


            # connect to the engine

            mdi_engine = mdi.MDI_Accept_Communicator()


            # create an array of atomic forces

            forces = np.zeros(3*natoms, dtype=float)


            # send the atomic forces to the engine

            mdi.MDI_Send_Command(">FORCES", mdi_engine)

            mdi.MDI_Send(forces, 3*natoms, mdi.MDI_DOUBLE, mdi_engine)

            '
        format: Sequentially ascending order of atomic index, with the forces for each
          individual atom being provided in xyz order.
    - <FORCES:
        count: 3 * NATOMS
        datatype: MDI_DOUBLE
        units: Hartree/Bohr
        description: Receive atomic forces.
        doc: 'If the engine is at the [@DEFAULT](#@DEFAULT-target) node, it calculates and sends
          its atomic forces to the driver.  These forces include all force contributions,
          including the force contributions associated with any constraint algorithm (e.g.
          SHAKE, RATTLE, etc.).  If the engine has previously calculated the atomic forces
          of the system,  and no intervening commands from the driver could have changed
          the atomic forces,  the engine is permitted to send the previously calculated
          atomic forces instead of recalculating them.
          '
        examples:
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the atomic forces
            std::vector<double> forces(3*natoms);

            // receive the atomic forces from the engine
            MDI_Send_Command("<FORCES", mdi_engine);
            MDI_Recv(forces.data(), 3*natoms, MDI_DOUBLE, mdi_engine);
          python: |
            import mdi
            
            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the atomic forces from the engine
            mdi.MDI_Send_Command("<FORCES", mdi_engine)
            forces = mdi.MDI_Recv(3*natoms, mdi.MDI_DOUBLE, mdi_engine)
          python (numpy): |
            import mdi
            import numpy as np
            
            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()
            
            # create a buffer to hold the atomic forces
            forces = np.zeros(3*natoms, dtype=float)
            
            # receive the atomic forces from the engine
            mdi.MDI_Recv(3*natoms, mdi.MDI_DOUBLE, mdi_engine, buf=forces)
        format: Sequentially ascending order of atomic index, with the forces for each
          individual atom being provided in xyz order.
    - '>+FORCES':
        count: 3 * NATOMS
        datatype: MDI_DOUBLE
        description: Send additional atomic forces.
        doc: 'The driver sends a set of additional atomic forces to the engine,  which
          adds these forces to its internal forces.
          '
        examples:
          cpp: |
            #include "mdi.h"
            #include <vector>
            
            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();
            
            // create a vector of additional atomic forces 

            // send the additional atomic forces to the engine
            MDI_Send_Command(">+FORCES", mdi_engine);
            MDI_Send(forces.data(), 3*natoms, MDI_DOUBLE, mdi_engine);
          python: |
            import mdi
            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()
            
            # create an array of additional atomic forces
            
            # send the additional atomic forces to the engine
            mdi.MDI_Send_Command(\">+FORCES\", mdi_engine)
            mdi.MDI_Send(forces, 3*natoms, mdi.MDI_DOUBLE, mdi_engine)"
        format: Sequentially ascending order of atomic index, with the forces for each
          individual atom being provided in xyz order.
DENSITY:
  category: 2
  summary: "Retrieve electronic density information."
  tags:
    - Quantum Mechanics
  commands:
    - '<DENSITY':
        count: 3 * NDENSITY
        datatype: MDI_DOUBLE
        description: Retrieve electronic density on a set of grid points.
        doc: > 
          The engine sends the value of its electronic density on a set of grid points. 
          This command is intended to be used in conjuction with the [<NDENSITY](NDENSITY) and [<CDENSITY](CDENSITY) commands; 
          these three commands enable a driver to acquire the electronic density distribution of an engine in a grid representation.
        examples:
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // receive the Cartesian coordinates of the grid points
            int ndensity;
            MDI_Send_Command("<NDENSITY", mdi_engine);
            MDI_Recv(&ndensity, 1, MDI_INT, mdi_engine);

            // create a vector to hold the Cartesian coordinates of the grid points
            std::vector<double> density(3*ndensity);

            // receive the electronic density on a set of grid points
            MDI_Send_Command("<DENSITY", mdi_engine);
            MDI_Recv(density.data(), 3*ndensity, MDI_DOUBLE, mdi_engine);
          python: |
            import mdi
            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # retrieve the number of grid points
            mdi.MDI_Send_Command("<NDENSITY", mdi_engine)
            ndensity = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)

            # receive the electronic density on a set of grid points
            mdi.MDI_Send_Command("<DENSITY", mdi_engine)
            density = mdi.MDI_Recv(3*ndensity, mdi.MDI_DOUBLE, mdi_engine)

          python (numpy): |
            import mdi
            import numpy as np

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # retrieve the number of grid points
            mdi.MDI_Send_Command("<NDENSITY", mdi_engine)
            ndensity = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)

            # create a buffer to hold the electronic density values
            density = np.zeros(3*ndensity, dtype=float)

            # receive the electronic density on a set of grid points
            mdi.MDI_Send_Command("<DENSITY", mdi_engine)
            mdi.MDI_Recv(3*ndensity, mdi.MDI_DOUBLE, mdi_engine, buf=density)
DIMENSIONS:
  category: 2
  summary: "Retrieve simulation cell dimensionality (periodic or non-periodic)."
  commands:
    - '<DIMENSIONS':
        count: 3
        datatype: MDI_INIT
        description: Retrieve simulation cell dimensions.
        doc: | 
          The engine sends basic information about the dimensionality of its system to the driver. For each of its three cell vectors (see the [<CELL](CELL) command) the engine sends an integer that indicates whether that dimension is represented as periodic, non-periodic, or not represented at all (in the case of 1d or 2d systems). 
          
          The possible values for each cell vector are:

          - 0: Not represented
          - 1: Non-periodic
          - 2: Periodic

        examples:
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the cell dimensions
            std::vector<int> dimensions(3);

            // receive the cell dimensions from the engine
            MDI_Send_Command("<DIMENSIONS", mdi_engine);
            MDI_Recv(dimensions.data(), 3, MDI_INT, mdi_engine)
          python: |
            import mdi
            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the cell dimensions from the engine
            mdi.MDI_Send_Command("<DIMENSIONS", mdi_engine)
            dimensions = mdi.MDI_Recv(3, mdi.MDI_INT, mdi_engine)
          python (numpy): |
            import mdi
            import numpy as np

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # create a buffer to hold the cell dimensions
            dimensions = np.empty(3, dtype=int)

            # receive the cell dimensions from the engine
            mdi.MDI_Send_Command("<DIMENSIONS", mdi_engine)
            mdi.MDI_Recv(3, mdi.MDI_INT, mdi_engine, buf=dimensions)
ELECT_MULT:
  category: 2
  summary: "Exchange electronic multiplicity."
  tags:
    - Quantum Mechanics
  commands:
    - '>ELECT_MULT':
        count: 1
        datatype: MDI_INT
        description: Send electronic multiplicity.
        doc: >
          The driver sends the electronic multiplicity of the system to the engine. 
          This command is typically only appropriate for quantum mechanics engines.
        examples:
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // send the electronic multiplicity to the engine
            int elect_mult = 1;
            MDI_Send_Command(">ELECT_MULT", mdi_engine);
            MDI_Send(&elect_mult, 1, MDI_INT, mdi_engine);

          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # send the electronic multiplicity to the engine
            elect_mult = 1
            mdi.MDI_Send_Command(">ELECT_MULT", mdi_engine)
    - <ELECT_MULT:
        count: 1
        datatype: MDI_INT
        description: Receive electronic multiplicity.
        doc: >
          The engine sends the electronic multiplicity of its system to the driver. 
          This command is typically only appropriate for quantum mechanics engines.
        examples:
          cpp: |
            #include "mdi.h"
            
            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the electronic multiplicity
            int elect_mult;

            // receive the electronic multiplicity from the engine
            MDI_Send_Command("<ELECT_MULT", mdi_engine);
            MDI_Recv(&elect_mult, 1, MDI_INT, mdi_engine);
          python: |
            import mdi
            
            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the electronic multiplicity from the engine
            mdi.MDI_Send_Command("<ELECT_MULT", mdi_engine)
            elect_mult = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)
ELEMENTS:
  category: 2
  summary: "Exchange atomic element information."
  commands:
    - '>ELEMENTS':
        count: NATOMS
        datatype: MDI_INT
        description: Send atomic numbers.
        doc: >
          The driver sends a set of atomic numbers to the engine, 
          which replaces the atomic number of each atom in its system with the values sent by the driver.
        examples:
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // retrieve the number of atoms
            int natoms;
            MDI_Send_Command("<NATOMS", mdi_engine);
            MDI_Recv(&natoms, 1, MDI_INT, mdi_engine);

            // create a vector of atomic numbers
            std::vector<int> elements(natoms);

            // send the atomic numbers to the engine
            MDI_Send_Command(">ELEMENTS", mdi_engine);
            MDI_Send(elements.data(), natoms, MDI_INT, mdi_engine);
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # retrieve the number of atoms
            mdi.MDI_Send_Command("<NATOMS", mdi_engine)
            natoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)

            # create a list of atomic numbers
            elements = # some array of atomic numbers

            # send the atomic numbers to the engine
            mdi.MDI_Send_Command(">ELEMENTS", mdi_engine)
            mdi.MDI_Send(elements, natoms, mdi.MDI_INT, mdi_engine)
        format:  Sequentially ascending order of atomic index.
    - <ELEMENTS:
        count: NATOMS
        datatype: MDI_INT
        description: Receive atomic numbers.
        doc: >
          The engine sends the atomic number of each atom in its system to the driver.
        examples:
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // retrieve the number of atoms
            int natoms;
            MDI_Send_Command("<NATOMS", mdi_engine);
            MDI_Recv(&natoms, 1, MDI_INT, mdi_engine);

            // create a buffer to hold the atomic numbers
            std::vector<int> elements(natoms);

            // receive the atomic numbers from the engine
            MDI_Send_Command("<ELEMENTS", mdi_engine);
            MDI_Recv(elements.data(), natoms, MDI_INT, mdi_engine);
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # retrieve the number of atoms
            mdi.MDI_Send_Command("<NATOMS", mdi_engine)
            natoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)

            # receive the atomic numbers from the engine
            mdi.MDI_Send_Command("<ELEMENTS", mdi_engine)
            elements = mdi.MDI_Recv(natoms, mdi.MDI_INT, mdi_engine)
          python(numpy): |
            import mdi
            import numpy as np

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # retrieve the number of atoms
            mdi.MDI_Send_Command("<NATOMS", mdi_engine)
            natoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)

            # create a buffer to hold the atomic numbers
            elements = np.zeros(natoms, dtype=int)

            # receive the atomic numbers from the engine
            mdi.MDI_Send_Command("<ELEMENTS", mdi_engine)
            mdi.MDI_Recv(natoms, mdi.MDI_INT, mdi_engine, buf=elements)
        format:  Sequentially ascending order of atomic index.
ENERGY:
  category: 2
  summary: "Receive total energy information."
  commands:
    - <ENERGY:
        count: 1
        datatype: MDI_DOUBLE
        description: Receive total energy.
        doc: >
          If the engine is at the @DEFAULT node, it calculates and sends the total energy of its system to the driver. 
          If the engine has previously calculated the energy of the system, and no intervening commands from the driver could have changed the energy, 
          the engine is permitted to send the previously calculated energy instead of recalculating it.
        examples:
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the total energy
            double energy;

            // receive the total energy from the engine
            MDI_Send_Command("<ENERGY", mdi_engine);
            MDI_Recv(&energy, 1, MDI_DOUBLE, mdi_engine);
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the total energy from the engine
            mdi.MDI_Send_Command("<ENERGY", mdi_engine)
            energy = mdi.MDI_Recv(1, mdi.MDI_DOUBLE, mdi_engine)
KE:
  category: 2
  summary: "Receive total kinetic energy."
  commands:
    - <KE:
        count: 1
        datatype: MDI_DOUBLE
        description: Receive total kinetic energy.
        doc: >
          If the engine is at the @DEFAULT node, it calculates and sends the total kinetic energy of to the driver. 
          If the engine has previously calculated the energy of the system, and no intervening commands from the driver could have changed the energy, 
          the engine is permitted to send the previously calculated energy instead of recalculating it.

          If the engine is not at the @DEFAULT node, it sends its most recently calculated nuclear kinetic energy to the driver.
        examples:
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the nuclear kinetic energy
            double kinetic_energy;

            // receive the nuclear kinetic energy from the engine
            MDI_Send_Command("<KE", mdi_engine);
            MDI_Recv(&kinetic_energy, 1, MDI_DOUBLE, mdi_engine);
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the nuclear kinetic energy from the engine
            mdi.MDI_Send_Command("<KE", mdi_engine)
            kinetic_energy = mdi.MDI_Recv(1, mdi.MDI_DOUBLE, mdi_engine)
KE_ELEC:
  category: 2
  summary: "Receive electronic kinetic energy."
  commands:
    - <KE_NUC:
        count: 1
        datatype: MDI_DOUBLE
        description: Receive kinetic energy of all electrons in the system.
        doc: >
          If the engine is at the @DEFAULT node, it calculates and sends the total kinetic energy of all electrons in its system to the driver. 
          If the engine has previously calculated the energy of the system, and no intervening commands from the driver could have changed the energy, 
          the engine is permitted to send the previously calculated energy instead of recalculating it.

          If the engine is not at the @DEFAULT node, it sends its most recently calculated electronic kinetic energy to the driver.
        examples:
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the nuclear kinetic energy
            double ke_elec;

            // receive the nuclear kinetic energy from the engine
            MDI_Send_Command("<KE_NUC", mdi_engine);
            MDI_Recv(&ke_elec, 1, MDI_DOUBLE, mdi_engine);
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the nuclear kinetic energy from the engine
            mdi.MDI_Send_Command("<KE_ELEC", mdi_engine)
            ke_elec = mdi.MDI_Recv(1, mdi.MDI_DOUBLE, mdi_engine)
KE_NUC:
  category: 2
  summary: "Receive nuclear kinetic energy."
  commands:
    - <KE_NUC:
        count: 1
        datatype: MDI_DOUBLE
        description: Receive nuclear kinetic energy.
        doc: >
          If the engine is at the @DEFAULT node, it calculates and sends the total kinetic energy of all nuclei in its system to the driver. 
          If the engine has previously calculated the energy of the system, and no intervening commands from the driver could have changed the energy, 
          the engine is permitted to send the previously calculated energy instead of recalculating it.

          If the engine is not at the @DEFAULT node, it sends its most recently calculated nuclear kinetic energy to the driver.
        examples:
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the nuclear kinetic energy
            double ke_nuc;

            // receive the nuclear kinetic energy from the engine
            MDI_Send_Command("<KE_NUC", mdi_engine);
            MDI_Recv(&ke_nuc, 1, MDI_DOUBLE, mdi_engine);
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the nuclear kinetic energy from the engine
            mdi.MDI_Send_Command("<KE_NUC", mdi_engine)
            ke_nuc = mdi.MDI_Recv(1, mdi.MDI_DOUBLE, mdi_engine)
LABELS:
  category: 2
  summary: "Receive a label for each atom in the system."
  commands:
    - <LABELS:
        count: MDI_LABEL_LENGTH * NATOMS
        datatype: MDI_CHAR
        description: Receive atom labels.
        format: An array of characters corresponding to the label of each atom in ascending order of atomic index, with each label consisting of `MDI_LABEL_LENGTH` characters and being padded with spaces where necessary.
        doc: >
          The engine sends a label for each atom in its system. 
          "Labels" are intended primarily for the purpose of providing a human-readable identifier for each of the atoms, 
          and do not have a standardized physical meaning. 
          It is recommended that the labels correspond to the element of each atom (i.e., "H", "He", "Li", etc.), 
          a name associated with atoms of a particular type (i.e., "Carboxyl_Hydrogen", "Methyl_Hydrogen"), 
          or a similarly descriptive term. 
          The atom labels may correspond to a number identifier (i.e., "1", "2", "3", etc.) in cases where more descriptive labels are not practical, 
          but note that such labels must be represented using the MDI_CHAR data type, as indicated below. 
          It is required that atoms having different physical properties (i.e., different force field terms in a molecular mechanics simulation or different nuclear charges in a quantum chemistry simulation) 
          have different labels.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # get the number of atoms
            mdi.MDI_Send_Command("<NATOMS", mdi_engine)
            natoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)

            # receive the atom labels from the engine
            mdi.MDI_Send_Command("<LABELS", mdi_engine)
            labels = mdi.MDI_Recv(MDI_LABEL_LENGTH * natoms, mdi.MDI_CHAR, mdi_engine)
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // get the number of atoms
            int natoms;
            MDI_Send_Command("<NATOMS", mdi_engine);
            MDI_Recv(&natoms, 1, MDI_INT, mdi_engine);

            // create a buffer to hold the atom labels
            std::<vector>char labels(MDI_LABEL_LENGTH * natoms);

            // receive the atom labels from the engine
            MDI_Send_Command("<LABELS", mdi_engine);
            MDI_Recv(labels, MDI_LABEL_LENGTH * natoms, MDI_CHAR, mdi_engine)
LATTICE:
  category: 2
  summary: "Send lattice point charges."
  commands:
    - '>LATTICE':
        count: NLATTICE
        datatype: MDI_DOUBLE
        description: Send lattice point charges
        tags:
          - Quantum Mechanics
          - Gas Phase Quantum Mechanics
        format: Sequentially ascending order of lattice charge index.
        doc: >
          This command, along with the [>NLATTICE](NLATTICE) and [>CLATTICE](CLATTICE) commands, 
          allows the driver to assign a lattice of point charges to an engine, 
          which incorporates the effects of these charges in all further calculations. 
          After sending this command, the driver sends the charges of each of the point charges to the engine. 
          Prior to sending this command, the driver must have set the number of point charges using the [>NLATTICE](NLATTICE) command.

          This command is primarily intended for use with gas-phase quantum mechanics codes. 
          For an alternative command that is more appropriate for plane wave quantum mechanics codes, 
          see the [>POTENTIAL](POTENTIAL) command.
        examples:
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // send nlattice points to the engine
            int nlattice = 10;
            MDI_Send_Command(">NLATTICE", mdi_engine);
            MDI_Send(&nlattice, 1, MDI_INT, mdi_engine);

            // create a buffer to hold the lattice point charges
            std::vector<double> lattice_charges(NLATTICE);

            // fill the lattice point charges with some values

            // send the lattice point charges to the engine
            MDI_Send_Command(">LATTICE", mdi_engine);
            MDI_Send(lattice_charges.data(), NLATTICE, MDI_DOUBLE, mdi_engine);
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # send nlattice points to the engine
            nlattice = 10
            mdi.MDI_Send_Command(">NLATTICE", mdi_engine)
            mdi.MDI_Send(nlattice, 1, mdi.MDI_INT, mdi_engine)

            # create a list of lattice point charges

            # send the lattice point charges to the engine
            mdi.MDI_Send_Command(">LATTICE", mdi_engine)
            mdi.MDI_Send(lattice_charges, NLATTICE, mdi.MDI_DOUBLE, mdi_engine)
LATTICE_FORCES:
  category: 2
  summary: "Receive lattice forces."
  commands:
    - <LATTICE_FORCES:
        count: 3 * NLATTICE
        datatype: MDI_DOUBLE
        description: Receive lattice forces on lattice charges.
        format: Sequentially ascending order of lattice charge index, with the forces for each individual lattice charge being provided in xyz order.
        tags:
          - Quantum Mechanics
          - Gas Phase Quantum Mechanics
        doc: 
          If the engine is at the [@DEFAULT](#@DEFAULT-target) node, it calculates and sends the forces on any lattice charges (which must have previously assigned with the [>LATTICE](#LATTICE) command) to the driver.
          Prior to sending this command, the driver must have set the number, coordinates, and magnitudes of the lattice charges using the [>NLATTICE](NLATTICE), [>CLATTICE](CLATTICE), and [>LATTICE](LATTICE) commands. 
          These forces must include only electrostatic interactions between the lattice charges and the atomic nuclei, and between the lattice charges and any electrons. 
          They must not include electrostatic interactions between the lattice charges and other lattice charges. 
          If the engine has previously calculated these forces, and no intervening commands from the driver could have changed the forces, the engine is permitted to send the previously calculated forces instead of recalculating them.  

          If the engine is not at the @DEFAULT node, it sends its most recently calculated lattice forces to the driver.  

          This command is primarily intended for use with gas-phase quantum mechanics codes.
        examples:
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // get lattice information
            std::vector<double> lattice; // some vector of lattice charges

            std::vector<double> clattice; // some vector of lattice charge coordinates

            int nlattice = lattice.size();

            // send the number of lattice points to the engine
            MDI_Send_Command(">NLATTICE", mdi_engine);
            MDI_Send(nlattice, 1, MDI_INT, mdi_engine);


            // send the lattice coordinates to the engine
            MDI_Send_Command(">CLATTICE", mdi_engine);
            MDI_Send(clattice, 3*nlattice, MDI_DOUBLE, mdi_engine);


            // send the lattice charges to the engine
            MDI_Send_Command(">LATTICE", mdi_engine);
            MDI_Send(clattice, nlattice, MDI_DOUBLE, mdi_engine);

            // receive the lattice forces from the engine
            std::vector<double> lattice_forces(3*nlattice);
            MDI_Send_Command("<LATTICE_FORCES", mdi_engine);
            MDI_Recv(lattice_forces.data(), 3*nlattice, MDI_DOUBLE, mdi_engine);
          python: |
            import mdi
            # connect to the engine

            mdi_engine = mdi.MDI_Accept_Communicator()

            # get lattice information
            lattice = # some array of lattice charges
            clattice = # some array of lattice charge coordintaes
            nlattice = len(lattice)

            # send the number of lattice points to the engine
            mdi.MDI_Send_Command(">NLATTICE", mdi_engine)
            mdi.MDI_Send(nlattice, 1, mdi.MDI_INT, mdi_engine)

            # send the lattice coordinates to the engine
            mdi.MDI_Send_Command(">CLATTICE", mdi_engine)
            mdi.MDI_Send(clattice, 3*nlattice, mdi.MDI_DOUBLE, mdi_engine)

            # send the lattice charges to the engine
            mdi.MDI_Send_Command(">LATTICE", mdi_engine)
            mdi.MDI_Send(clattice, nlattice, mdi.MDI_DOUBLE, mdi_engine)

            # receive the lattice forces from the engine
            lattice_forces = mdi.MDI_Recv(3*nlattice, mdi.MDI_DOUBLE, mdi_engine)
          python(numpy): |
            import mdi
            import numpy as np

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # get lattice information
            lattice = # some array of lattice charges
            clattice = # some array of lattice charge coordintaes
            nlattice = len(lattice)

            # send the number of lattice points to the engine
            mdi.MDI_Send_Command(">NLATTICE", mdi_engine)
            mdi.MDI_Send(nlattice, 1, mdi.MDI_INT, mdi_engine)

            # send the lattice coordinates to the engine
            mdi.MDI_Send_Command(">CLATTICE", mdi_engine)
            mdi.MDI_Send(clattice, 3*nlattice, mdi.MDI_DOUBLE, mdi_engine)

            # send the lattice charges to the engine
            mdi.MDI_Send_Command(">LATTICE", mdi_engine)
            mdi.MDI_Send(clattice, nlattice, mdi.MDI_DOUBLE, mdi_engine)

            # receive the lattice forces from the engine
            lattice_forces = np.zeros(3*nlattice, dtype=float)
            mdi.MDI_Recv(3*nlattice, mdi.MDI_DOUBLE, mdi_engine, buf=lattice_forces)
MASSES:
  category: 2
  summary: "Retrieve atom masses."
  commands: 
    - <MASSES:
        count: NATOMS
        datatype: MDI_DOUBLE
        description: Receive atom masses
        doc: |
          The engine sends the driver the mass of each of the atoms.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # get the number of atoms
            mdi.MDI_Send_Command("<NATOMS", mdi_engine)
            natoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)

            # receive the atom masses from the engine
            mdi.MDI_Send_Command("<MASSES", mdi_engine)
            masses = mdi.MDI_Recv(natoms, mdi.MDI_DOUBLE, mdi_engine)
          python (numpy): |
            import mdi
            import numpy as np

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # get the number of atoms
            mdi.MDI_Send_Command("<NATOMS", mdi_engine)
            natoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)

            # create a buffer to hold the atom masses
            masses = np.zeros(natoms, dtype=float)

            # receive the atom masses from the engine
            mdi.MDI_Send_Command("<MASSES", mdi_engine)
            mdi.MDI_Recv(natoms, mdi.MDI_DOUBLE, mdi_engine, buf=masses)
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // get the number of atoms
            int natoms;
            MDI_Send_Command("<NATOMS", mdi_engine);
            MDI_Recv(&natoms, 1, MDI_INT, mdi_engine);

            // create a buffer to hold the atom masses
            std::vector<double> masses(natoms);

            // receive the atom masses from the engine
            MDI_Send_Command("<MASSES", mdi_engine);
            MDI_Recv(masses.data(), natoms, MDI_DOUBLE, mdi_engine)
MONKHORST-PACK_NPOINTS:
  category: 2
  summary: "Send number of points for a Monkhorst-Pack grid."
  tags:
    - Quantum Mechanics
    - DFT
    - Plane Wave DFT
  commands:
    - '>MONKHORST-PACK_NPOINTS':
        count: 3
        datatype: MDI_INT
        description: Send Monkhorst-Pack grid points
        format: The number of k-points to generate along each vector of the Brillouin zone, in ascending order of vector.
        doc: 'This command is typically expected for use with plane wave DFT engines.  The
          driver sends the engine the number of k-points to generate on a Monkhorst-Pack
          grid.  The engine then uses the k-points generated on this Monkhorst-Pack grid
          for all further simulations.
          '
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # send the number of k-points to generate on a Monkhorst-Pack grid
            mdi.MDI_Send_Command(">MONKHORST-PACK_NPOINTS", mdi_engine)
            mdi.MDI_Send([10, 10, 10], 3, mdi.MDI_INT, mdi_engine)
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // send the number of k-points to generate on a Monkhorst-Pack grid
            std::vector<int> npts = {10, 10, 10};

            // send the number of k-points to generate on a Monkhorst-Pack grid
            MDI_Send_Command(">MONKHORST-PACK_NPOINTS", mdi_engine);
            MDI_Send(npts.data(), 3, MDI_INT, mdi_engine);          
MONKHORST-PACK_SHIFT:
  category: 2
  summary: "Send Monkhorst-Pack grid shift."
  tags:
    - Quantum Mechanics
    - DFT
    - Plane Wave DFT
  commands:
    - '>MONKHORST-PACK_SHIFT':
        count: 3
        datatype: MDI_DOUBLE
        description: Send Monkhorst-Pack grid shift
        admonition:
          type: note
          title: "Note"
          content: Some engines can only support values of 0.0 or 0.5.
        format: |
          The fraction of a grid step by which the k-points should be displaced, in ascending order of vector. 
          A value of 0.0 indicates no displacement along the corresponding vector, while a value of 0.5 indicates a displacement of half a grid step in along the corresponding vector. 
          Note that some engines can only support values of 0.0 or 0.5.
        doc: |
          This command is typically expected for use with plane wave DFT engines. 
          The driver sends the engine a set of values that indicate the extent to which a set of k-points on a Monkhorst-Pack grid should be displaced relative to the original (non-displaced) Monkhorst-Pack grid. 
          The engine then uses the shifted k-points for all further simulations.  
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # send the Monkhorst-Pack grid shift
            mdi.MDI_Send_Command(">MONKHORST-PACK_SHIFT", mdi_engine)
            mdi.MDI_Send([0.0, 0.0, 0.0], 3, mdi.MDI_DOUBLE, mdi_engine)
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // send the Monkhorst-Pack grid shift
            std::vector<double> shift = {0.0, 0.0, 0.0};

            // send the Monkhorst-Pack grid shift
            MDI_Send_Command(">MONKHORST-PACK_SHIFT", mdi_engine);
            MDI_Send(shift.data(), 3, MDI_DOUBLE, mdi_engine);
NAME:
  category: 3
  summary: "Receive engine name."
  commands:
    - <NAME:
        category: 3
        count: MDI_NAME_LENGTH
        datatype: MDI_CHAR
        description: Receive engine name
        doc: Engine sends its name as per `-name` option in MDI initialization.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the engine name from the engine
            mdi.MDI_Send_Command("<NAME", mdi_engine)
            name = mdi.MDI_Recv(MDI_NAME_LENGTH, mdi.MDI_CHAR, mdi_engine)
          cpp: |
            #include "mdi.h"
            #include <vector>

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the engine name
            std::vector<char> name(MDI_NAME_LENGTH);

            // receive the engine name from the engine
            MDI_Send_Command("<NAME", mdi_engine);
            MDI_Recv(name.data(), MDI_NAME_LENGTH, MDI_CHAR, mdi_engine)
NATOMS:
  category: 2
  summary: "Receive number of atoms."
  commands:
    - <NATOMS:
        category: 2
        count: 1
        datatype: MDI_INT
        description: Receive number of atoms
        doc: The engine sends the driver the number of atoms in the engine's system.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the number of atoms from the engine
            mdi.MDI_Send_Command("<NATOMS", mdi_engine)
            natoms = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the number of atoms
            int natoms;

            // receive the number of atoms from the engine
            MDI_Send_Command("<NATOMS", mdi_engine);
            MDI_Recv(&natoms, 1, MDI_INT, mdi_engine);
NDENSITY:
  category: 2
  summary: "Receive number of points for electronic density on a grid."
  commands:
    - <NDENSITY:
        count: 1
        datatype: MDI_INT
        description: Receive number of density grid points
        doc: |
          The engine sends the number of grid points it is using to represent its electronic density on a grid. 
          This command is intended to be used in conjuction with the [<CDENSITY](CDENSITY) and [<DENSITY](DENSITY) commands; 
          these three commands enable a driver to acquire the electronic density distribution of an engine in a grid representation. 
          See the [<DENSITY](DENSITY) command for more details.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the number of density grid points from the engine
            mdi.MDI_Send_Command("<NDENSITY", mdi_engine)
            ndensity = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the number of density grid points
            int ndensity;

            // receive the number of density grid points from the engine
            MDI_Send_Command("<NDENSITY", mdi_engine);
            MDI_Recv(&ndensity, 1, MDI_INT, mdi_engine);
NLATTICE:
  category: 2
  summary: "Send number of lattice points."
  tags: 
    - Quantum Mechanics
    - Gas Phase Quantum Mechanics
  commands:
    - '>NLATTICE':
        category: 2
        count: 1
        datatype: MDI_INT
        description: Send number of lattice points
        doc: |
          This command, along with the [>CLATTICE](CLATTICE) and [>LATTICE](LATTICE) commands, allows the driver to assign a lattice of point charges to an engine, which incorporates the effects of these charges in all further calculations. 
          After sending this command, the driver sends the number of point charges to the engine. This command must be sent before either the [>CLATTICE](CLATTICE) or [>LATTICE](LATTICE) commands can be sent.

          This command is primarily intended for use with gas-phase quantum mechanics codes. For an alternative command that is more appropriate for plane wave quantum mechanics codes, see the [>POTENTIAL](POTENTIAL) command.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # send the number of lattice points to the engine
            nlattice = 10
            mdi.MDI_Send_Command(">NLATTICE", mdi_engine)
            mdi.MDI_Send(nlattice, 1, mdi.MDI_INT, mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // send the number of lattice points to the engine
            int nlattice = 10;
            MDI_Send_Command(">NLATTICE", mdi_engine);
            MDI_Send(&nlattice, 1, MDI_INT, mdi_engine);
NPOTENTIAL:
  category: 2
  summary: "Send the number of potential grid points."
  tags:
        - Quantum Mechanics
  commands:
    - '>NPOTENTIAL':
        count: 1
        datatype: MDI_INT
        description: Send number of potential grid points
        doc: 'The driver sends the number of grid points it is using to represent a potential
          on a grid.  This command is intended to be used in conjuction with the [>CPOTENTIAL](CPOTENTIAL)
          and [>POTENTIAL](POTENTIAL) commands;  these three commands enable a driver
          to set an external potential that is incorporated into a subsequent scf_command
          command.  See the [>POTENTIAL](POTENTIAL) command for more details.

          '
        examples:
          cpp: '#include "mdi.h"


            // connect to the engine

            MDI_Comm mdi_engine = MDI_Accept_Communicator();


            // create a variable for the number of potential grid points
            
            int npotential = 10


            // send the number of potential grid points to the engine

            MDI_Send_Command(">NPOTENTIAL", mdi_engine);

            MDI_Send(&npotential, 1, MDI_INT, mdi_engine);

            '
          python: 'import mdi


            # connect to the engine

            mdi_engine = mdi.MDI_Accept_Communicator()


            # set the number of potential points

            npotential = 10


            # send the number of potential grid points to the engine

            mdi.MDI_Send_Command(">NPOTENTIAL", mdi_engine)

            mdi.MDI_Send(npotential, 1, mdi.MDI_INT, mdi_engine)

            '
POTENTIAL:
  category: 2
  summary: "Send potential grid values."
  commands:
    - '>POTENTIAL':
        count: NPOTENTIAL
        datatype: MDI_DOUBLE
        description: Send potential grid values.
        doc: |
          The driver sends an set of values to the engine that correspond to a potential on a grid. 
          If an scf_command command is later issued, this potential will be incorporated into the SCF calculation as an external potential.

          Before sending this command, the driver must have first sent the number of grid points used to represent the potential via the [>NPOTENTIAL](NPOTENTIAL) command. 
          It is also necessary that the driver send the Cartesian coordinates of the grid points via the [>CPOTENTIAL](CPOTENTIAL) command prior to any subsequent scf_command command.
        examples:
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // send the number of potential grid points to the engine
            int npotential = 10;
            MDI_Send_Command(">NPOTENTIAL", mdi_engine);
            MDI_Send(&npotential, 1, MDI_INT, mdi_engine);

            // create vector of the potential grid points with npotential elements

            // send the potential grid points to the engine
            MDI_Send_Command(">POTENTIAL", mdi_engine);
            MDI_Send(&potential, npotential, MDI_DOUBLE, mdi_engine);
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # send the number of potential grid points to the engine
            npotential = 10
            mdi.MDI_Send_Command(">NPOTENTIAL", mdi_engine)
            mdi.MDI_Send(npotential, 1, mdi.MDI_INT, mdi_engine)

            # create a list of potential grid points with npotential elements

            # send the potential grid points to the engine
            mdi.MDI_Send_Command(">POTENTIAL", mdi_engine)
            mdi.MDI_Send(potential, npotential, mdi.MDI_DOUBLE, mdi_engine)
PE:
  category: 2
  summary: "Receive total potential energy."
  commands:
    - '<PE':
        count: 1
        datatype: MDI_DOUBLE
        description: Receive number of potential grid points
        doc: |
          If the engine is at the [@DEFAULT](#@DEFAULT-target) node, it calculates and sends its total potential energy to the driver. 
          If the engine has previously calculated the energy of the system, and no intervening commands from the driver could have changed the energy, 
          the engine is permitted to send the previously calculated energy instead of recalculating it.

          If the engine is not at the [@DEFAULT](#@DEFAULT-target) node, it sends its most recently calculated total potential energy to the driver.
        examples:
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the total potential energy
            double pe;

            // receive the total potential energy from the engine
            MDI_Send_Command("<PE", mdi_engine);
            MDI_Recv(&pe, 1, MDI_DOUBLE, mdi_engine);   
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the total potential energy from the engine
            mdi.MDI_Send_Command("<PE", mdi_engine)
            pe = mdi.MDI_Recv(1, mdi.MDI_DOUBLE, mdi_engine)           
PE_ELEC:
  category: 2
  summary: "Receive electronic potential energy."
  commands:
    - <PE_ELEC:
        count: 1
        datatype: MDI_DOUBLE
        description: Receive electronic potential energy.
        doc: |
          If the engine is at the [@DEFAULT](#@DEFAULT-target) node, it calculates and sends its electronic potential energy to the driver. 
          The electronic potential energy is defined as including all interactions between the electrons and any other particles or fields in the system. 
          It also includes the interactions between the electrons and themselves. If the engine has previously calculated the energy of the system, and no intervening commands from the driver could have changed the energy, 
          the engine is permitted to send the previously calculated energy instead of recalculating it.

          If the engine is not at the [@DEFAULT](#@DEFAULT-target) node, it sends its most recently calculated electronic potential energy to the driver.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the electronic potential energy from the engine
            mdi.MDI_Send_Command("<PE_ELEC", mdi_engine)
            pe_elec = mdi.MDI_Recv(1, mdi.MDI_DOUBLE, mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the electronic potential energy
            double pe_elec;

            // receive the electronic potential energy from the engine
            MDI_Send_Command("<PE_ELEC", mdi_engine);
            MDI_Recv(&pe_elec, 1, MDI_DOUBLE, mdi_engine);
PE_NUC: 
  category: 2
  summary: "Receive nuclear potential energy."
  commands:
    - <PE_NUC:
        count: 1
        datatype: MDI_DOUBLE
        description: Receive nuclear potential energy
        doc: |
          If the engine is at the [@DEFAULT](#@DEFAULT-target) node, it calculates and sends its nuclear potential energy to the driver. 
          The nuclear potential energy is defined as including all interactions between the nuclei and any other particles or fields in the system, excluding any electrons. 
          It also includes the interactions between the nuclei and themselves. 
          If the engine has previously calculated the energy of the system, and no intervening commands from the driver could have changed the energy, 
          the engine is permitted to send the previously calculated energy instead of recalculating it.

          If the engine is not at the [@DEFAULT](#@DEFAULT-target) node, it sends its most recently calculated nuclear potential energy to the driver.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the nuclear potential energy from the engine
            mdi.MDI_Send_Command("<PE_NUC", mdi_engine)
            pe_nuc = mdi.MDI_Recv(1, mdi.MDI_DOUBLE, mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the nuclear potential energy
            double pe_nuc;

            // receive the nuclear potential energy from the engine
            MDI_Send_Command("<PE_NUC", mdi_engine);
            MDI_Recv(&pe_nuc, 1, MDI_DOUBLE, mdi_engine);
SPIN_POLARIZATION:
  category: 2
  summary: "Exchange spin polarization information."
  tags:
    - Quantum Mechanics
    - DFT
    - Plane Wave DFT
  commands:
    - <SPIN_POLARIZATION:
        count: 1
        datatype: MDI_INT
        description: Receive spin polarization setting.
        format: |
          A value of 0 indicates that simulations will be performed in a non-spin-polarized manner. 
          A value of 1 indicates that simulations will be performed in a spin-polarized manner,
          within the local spin density approximation (LSDA). 
          A value of 2 indicates that simulations will be performed in a spin-polarized, noncollinear manner.
        doc: |
          The engine sends a value that indicates the manner in which it is currently simulating spin polarization. 
          This command is typically intended for use with plane wave DFT engines.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the spin polarization setting from the engine
            mdi.MDI_Send_Command("<SPIN_POLARIZATION", mdi_engine)
            spin_polarization = mdi.MDI_Recv(1, mdi.MDI_INT, mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the spin polarization setting
            int spin_polarization;

            // receive the spin polarization setting from the engine
            MDI_Send_Command("<SPIN_POLARIZATION", mdi_engine);
            MDI_Recv(&spin_polarization, 1, MDI_INT, mdi_engine);
    - '>SPIN_POLARIZATION':
        count: 1
        datatype: MDI_INT
        description: Send spin polarization setting.
        format: |
          A value of 0 indicates that simulations will be performed in a non-spin-polarized manner. 
          A value of 1 indicates that simulations will be performed in a spin-polarized manner,
          within the local spin density approximation (LSDA). 
          A value of 2 indicates that simulations will be performed in a spin-polarized, noncollinear manner.
        doc: |
          The driver sends a value that indicates the manner in which spin polarization should be simulated by the engine. 
          This command is typically intended for use with plane wave DFT engines.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # send the spin polarization setting to the engine
            mdi.MDI_Send_Command(">SPIN_POLARIZATION", mdi_engine)
            mdi.MDI_Send(1, 1, mdi.MDI_INT, mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // send the spin polarization setting to the engine
            int spin_polarization = 1;
            MDI_Send_Command(">SPIN_POLARIZATION", mdi_engine);
            MDI_Send(&spin_polarization, 1, MDI_INT, mdi_engine);
STRESS:
  category: 2
  summary: "Exchange virial stress tensor."
  commands:
    - <STRESS:
        count: 9
        datatype: MDI_DOUBLE
        description: Receive virial stress tensor
        doc: >
          The driver sends a virial stress tensor to the engine, 
          which replaces its internal stress tensor with the stress tensor sent by the driver.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the virial stress tensor from the engine
            mdi.MDI_Send_Command("<STRESS", mdi_engine)
            stress = mdi.MDI_Recv(9, mdi.MDI_DOUBLE, mdi_engine)
          python (numpy): |
            import mdi
            import numpy as np

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # create a buffer to hold the virial stress tensor
            stress = np.zeros(9, dtype=float)

            # receive the virial stress tensor from the engine
            mdi.MDI_Send_Command("<STRESS", mdi_engine)
            mdi.MDI_Recv(9, mdi.MDI_DOUBLE, mdi_engine, buf=stress)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the virial stress tensor
            double stress[9];

            // receive the virial stress tensor from the engine
            MDI_Send_Command("<STRESS", mdi_engine);
            MDI_Recv(stress, 9, MDI_DOUBLE, mdi_engine);
    - '>STRESS':
        count: 9
        datatype: MDI_DOUBLE
        description: Send virial stress tensor
        doc: Driver sends virial stress tensor to engine, replacing its internal tensor.
TOTCHARGE:
  category: 2
  summary: "Exchange total charge information"
  commands:
    - '>TOTCHARGE':
        category: 2
        count: 1
        datatype: MDI_DOUBLE
        description: Send total system charge
        doc: |
          The driver sends a value for the total charge of the system, including electron and nuclear charges, to the engine, 
          which adjusts the number of electrons present in its system to the value required to reproduce the value sent by the driver. 
          This command is typically only appropriate for quantum mechanics engines. 
          Engines that support this command are not required to support non-integer charges; they are permitted to produce an error message if the value received deviates by more than 10^-12 from an integer, 
          and to otherwise round the value received to the nearest integer.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # send the total charge of the system to the engine
            mdi.MDI_Send_Command(">TOTCHARGE", mdi_engine)
            mdi.MDI_Send(0.0, 1, mdi.MDI_DOUBLE, mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // send the total charge of the system to the engine
            double totcharge = 0.0;
            MDI_Send_Command(">TOTCHARGE", mdi_engine);
            MDI_Send(&totcharge, 1, MDI_DOUBLE, mdi_engine);
    - <TOTCHARGE:
        category: 2
        count: 1
        datatype: MDI_DOUBLE
        description: Receive total system charge
        doc: |
          The engine sends the total charge of its system, including electron and nuclear charges, to the driver.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the total charge of the system from the engine
            mdi.MDI_Send_Command("<TOTCHARGE", mdi_engine)
            totcharge = mdi.MDI_Recv(1, mdi.MDI_DOUBLE, mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the total charge of the system
            double totcharge;

            // receive the total charge of the system from the engine
            MDI_Send_Command("<TOTCHARGE", mdi_engine);
            MDI_Recv(&totcharge, 1, MDI_DOUBLE, mdi_engine)
VELOCITES:
  category: 2
  summary: "Exchange atomic velocities."
  commands:
    - '>VELOCITES':
        count: 3 * NATOMS
        datatype: MDI_DOUBLE
        description: Send atomic velocities.
        format: |
          Sequentially ascending order of atom index, with the velocities for each individual atom being provided in xyz order.
        doc: |
            The driver sends a set of atomic velocities to the driver, which replaces its atomic velocities with those provided by the driver.
        exmaples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # send the atomic velocities to the engine
            mdi.MDI_Send_Command(">VELOCITES", mdi_engine)
            mdi.MDI_Send(velocities, 3*NATOMS, mdi.MDI_DOUBLE, mdi_engine)
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // send the atomic velocities to the engine
            MDI_Send_Command(">VELOCITES", mdi_engine);
            MDI_Send(velocities, 3*NATOMS, MDI_DOUBLE, mdi_engine);
    - <VELOCITES:
        count: 3 * NATOMS
        datatype: MDI_DOUBLE
        description: Receive atomic velocities.
        format: |
          Sequentially ascending order of atom index, with the velocities for each individual atom being provided in xyz order.
        doc: |
          The engine sends the velocities of the atoms in its system to the driver.
        examples:
          python: |
            import mdi

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # receive the atomic velocities from the engine
            mdi.MDI_Send_Command("<VELOCITES", mdi_engine)
            velocities = mdi.MDI_Recv(3*NATOMS, mdi.MDI_DOUBLE, mdi_engine)
          python (numpy): |
            import mdi
            import numpy as np

            # connect to the engine
            mdi_engine = mdi.MDI_Accept_Communicator()

            # create a buffer to hold the atomic velocities
            velocities = np.zeros(3*NATOMS, dtype=float)

            # receive the atomic velocities from the engine
            mdi.MDI_Send_Command("<VELOCITES", mdi_engine)
            mdi.MDI_Recv(3*NATOMS, mdi.MDI_DOUBLE, mdi_engine, buf=velocities
          cpp: |
            #include "mdi.h"

            // connect to the engine
            MDI_Comm mdi_engine = MDI_Accept_Communicator();

            // create a buffer to hold the atomic velocities
            double velocities[3*NATOMS];

            // receive the atomic velocities from the engine
            MDI_Send_Command("<VELOCITES", mdi_engine);
            MDI_Recv(velocities, 3*NATOMS, MDI_DOUBLE, mdi_engine);
VERSION:
  category: 3
  summary: "Receive MDI Library version."
  commands:
  - <VERSION:
      count: 1
      datatype: MDI_DOUBLE
      description: Receive MDI Library version
      doc: The engine sends the version number of the MDI Library to which it is linked to the driver.
      examples:
        python: |
          import mdi

          # connect to the engine
          mdi_engine = mdi.MDI_Accept_Communicator()

          # receive the MDI Library version from the engine
          mdi.MDI_Send_Command("<VERSION", mdi_engine)
          version = mdi.MDI_Recv(1, mdi.MDI_DOUBLE, mdi_engine)
        cpp: |
          #include "mdi.h"

          // connect to the engine
          MDI_Comm mdi_engine = MDI_Accept_Communicator();

          // create a buffer to hold the MDI Library version
          double version;

          // receive the MDI Library version from the engine
          MDI_Send_Command("<VERSION", mdi_engine);
          MDI_Recv(&version, 1, MDI_DOUBLE, mdi_engine)

