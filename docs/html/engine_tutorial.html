<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-TFBQ45D');</script>
<!-- End Google Tag Manager -->
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Molssi Driver Interface Library: Engine Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
 <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TFBQ45D"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
  <td id="projectlogo"><img alt="Logo" src="mdi_main_logo_text_300x204.png"/></td>
  <td id="projectalign" style="padding-left: 6.0em;">
   <div id="projectname">Molssi Driver Interface Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Engine Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="engine_tutorial_intro"></a>
Introduction</h1>
<p>This tutorial will guide you through the process of implementing a support for MDI in an existing engine.</p>
<p>If you just want a quick tl;dr summary of the minimum steps involved in implementing an MDI interface, see the following:</p><ol type="1">
<li>If your engine is written in a compiled language, build and link your engine against MDI just like any other library. If it is written in Python, just import the MDI Library.</li>
<li>Add a way for end-users of your engine to send runtime options to the MDI Library, preferably through a <code>-mdi</code> command-line option.</li>
<li>Call <code><a class="el" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911" title="Initialize communication through the MDI library.">MDI_Init()</a></code> and <code><a class="el" href="mdi_8c.html#a21a41738e9b43ab70c977f8ce63c0957" title="Accept a new MDI communicator.">MDI_Accept_communicator()</a></code> as early as possible in your engine.</li>
<li>Add some server-like code that allows your engine to listen for commands via MDI and respond to them appropriately.</li>
<li>If your engine uses the Message Passing Interface (MPI), be aware that the MDI Library provides a replacement for MPI_COMM_WORLD, and that some MDI functions should only be called by <code>rank 0</code>.</li>
</ol>
<p> 
<style>
code
{
    color: #733;
}

.tab {
  overflow: hidden;
  border: 1px solid #ccc;
  background-color: #b1bfde;
}

.tab button {
  background-color: inherit;
  float: left;
  border: none;
  outline: none;
  cursor: pointer;
  padding: 6px 16px;
  transition: 0.3s;
  font-size: 17px;
}

.tab button:hover {
  background-color: #a2b6e1;
}

.tab button.active {
  background-color: #96ade0;
}

.tab button.cxx, button.fortran, button.python {
}

.tabcontent {
  display: none;
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-top: none;
  background-color: #e1e7f6;
}
.tabcontent.cxx, .tabcontent.fortran, .tabcontent.python {
}
</style>
<script>
function revealTabContent(evt, code_name) {
  var i, tabcontent, tabbuttons;
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }
  tabbuttons = document.getElementsByClassName("tabbuttons");
  for (i = 0; i < tabbuttons.length; i++) {
    tabbuttons[i].className = tabbuttons[i].className.replace(" active", "");
  }

  var content_name = "tabcontent";
  content_name = content_name.concat(" ");
  content_name = content_name.concat(code_name);
  var contents = document.getElementsByClassName(content_name);
  for (i = 0; i < contents.length; i++) {
    contents[i].style.display = "block";
  }

  var button_name = "tabbuttons";
  button_name = button_name.concat(" ");
  button_name = button_name.concat(code_name);
  tabbuttons = document.getElementsByClassName(button_name);
  for (i = 0; i < tabbuttons.length; i++) {
    tabbuttons[i].className += " active";
  }
}
</script>
</p>
<h1><a class="anchor" id="engine_tutorial_dependencies"></a>
Step 1: Prepare basic requirements</h1>
<p>In order to simplify the process of implementing, testing, and analyzing the capabilities of an MDI engine in a portable environment, this tutorial makes use of several tools. These tools include Git, GitHub, MDI Mechanic, and Docker. Please install each of these tools now:</p><ul>
<li>If you don't already have a GitHub account, create one now.</li>
<li>If you have never used Git, you may wish to work through <a href="https://education.molssi.org/python_scripting_cms/09-version-control/index.html">a quick tutorial on Git</a>, first.</li>
<li>Install MDI Mechanic. This can be done using pip, (<em>i.e.</em> <code>pip install mdimechanic</code>).</li>
<li>Install Docker and launch Docker Desktop, if applicable. You don't need to create a DockerHub account. You also don't need to know much about using Docker, as MDI Mechanic will handle those details for you.</li>
</ul>
<p>Note that although the above are requirements of this tutorial, none of them are required of end-users running your code.</p>
<h1><a class="anchor" id="engine_tutorial_repo"></a>
Step 2: Initialize an MDI report repository</h1>
<p>In this step of the tutorial, we will create a new GitHub repository to assist in the process of implementing, testing, and maintaining MDI support in your code. This new repository will be separate and independent from any repositories already associated with your code, and will henceforth be referred to as your <b>report repository</b>.</p>
<p>Create your report repository by making a new repository on GitHub. This repository does <b>not</b> need to include the source code of your engine, so you can make this repository publically accessible even if your source code is maintained privately. Don't initialize the repository with a <code>README</code> file or a <code>.gitignore</code> file. You can select whatever license you prefer; since this repository is separate from the repository that holds your engine's source code, it does not need to be the same license governing your engine's code.</p>
<p>Clone the newly created repository onto your local machine: </p><div class="fragment"><div class="line">git clone git@github.com:&lt;organization&gt;/&lt;repo_name&gt;.git</div><div class="line">cd &lt;repo_name&gt;</div></div><!-- fragment --><p>Now use MDI Mechanic to create the initial structure for this report repository: </p><div class="fragment"><div class="line">cd &lt;repo_name&gt;</div><div class="line">mdimechanic startproject --enginereport</div></div><!-- fragment --><p> This will add several new files to your report repository, including one called <code>mdimechanic.yml</code>.</p>
<h1><a class="anchor" id="engine_tutorial_yaml"></a>
Step 3: Configure the MDI Mechanic YAML file</h1>
<p>The <code>mdimechanic.yml</code> file created in the previous step is used by MDI Mechanic to build your engine and to test and analyze its functionality as an MDI engine. If you have used continuous integration (CI) testing services in the past, you will likely recognize many similarities between <code>mdimechanic.yml</code> and the YAML files that are often used by those services. Open <code>mdimechanic.yml</code> in your favorite text editor, and you will see that MDI Mechanic pre-populated this file with a basic template.</p>
<p>This tutorial will go over each field in <code>mdimechanic.yml</code> in detail, but the following is a quick summary:</p><ul>
<li><b>code_name:</b> The name of your code, which is used when printing out information.</li>
<li><b>image_name:</b> MDI Mechanic will create an Docker image, which will contain a highly portable environment that can be used to reproducibly build and run your engine. This field sets the name of the engine MDI Mechanic will create.</li>
<li><b>build_image</b>: This provides a script that is used to build the Docker image that MDI Mechanic builds. It corresponds to the steps required to prepare an environment with all of your engine's dependencies, and is comparable to a <code>before_install</code> step in some CI services.</li>
<li><b>build_engine</b>: This provides a script to build your engine. It is executed within the context of the Docker image built by MDI Mechanic, and is comparable to an <code>install</code> step in some CI services.</li>
<li><b>validate_engine</b>: This provides a script to verify that your engine has been built successfully. It is comparable to a <code>script</code> step in some CI services.</li>
<li><b>engine_tests</b>: This provides scripts used to test MDI functionality in your engine.</li>
</ul>
<p>For now, just replace the value of <code>code_name</code> with the name of your engine, and set the value of <code>image_name</code> to something appropriate. The naming convention for Docker images is <code>&lt;organization_name&gt;/&lt;image_name&gt;</code>, and we recommend that you follow this convention when setting <code>image_name</code>. If in doubt, you can set <code>image_name</code> to <code>&lt;engine_name&gt;/mdi_report</code>.</p>
<h1><a class="anchor" id="engine_tutorial_image"></a>
Step 4: Define your engine's build environment using MDI Mechanic</h1>
<p>This tutorial uses MDI Mechanic, which in turn runs your code within the context of a Docker image. In crude terms, you can think of an image as being a simulated duplicate of another computer, which has a different environment from yours (<em>i.e.</em> different installed libraries and system settings), and might be running an entirely different operating system. The image created by MDI Mechanic is based on the Ubunto Linux distribution. Starting from the basic Linux environment, MDI Mechanic installs some basic compilers (gcc, g++, and gfortran), an MPI library (MPICH), Python 3, and a handful of other dependencies (make and openssh). To finish building the image, MDI Mechanic executes whatever script you've provided in the <code>build_image</code> section of <code>mdimechanic.yml</code>.</p>
<p>You should now fill out <code>build_image</code> with an appropriate script that installs any dependencies necessary to compile your engine (if your engine is written in a compiled language) or to run your engine (if your engine is written in an interpreted language). To do this, imagine that someone handed you a Linux computer that is completely new and unused, except that the compilers and libraries mentioned in the preceeding paragraph have been installed on it. What would you need to do in order to install all the dependencies for your code? The answer to this question corresponds to the script you need to provide to <code>build_image</code>.</p>
<h1><a class="anchor" id="engine_tutorial_build"></a>
Step 5: Build your engine using MDI Mechanic</h1>
<p>After you've finished with the <code>build_image</code> script, it is time to write the <code>build_engine</code> script. This script will be executed within the context of the image you described in the <code>build_image</code> script, so it will have access to any dependencies you installed in that script (and <em>only</em> those dependencies). To write the <code>build_engine</code> script, ask yourself "What would someone need to type into their terminal to acquire a copy of my code's source and compile it?"; the answer to this question corresponds to the script you need to provide to <code>build_engine</code>. Here are a few important details to keep in mind as you write the <code>build_engine</code> script:</p><ul>
<li>The initial working directory for the <code>build_engine</code> script is the top-level directory of your report repository.</li>
<li>The <code>build_engine</code> script can access and manipulate any files within your report repository, including creating new files and subdirectories. It does not have access to any other files or directories on you filesystem (for Docker afficianados: the report repository's top-level directory is mounted within the image to <code>/repo</code>).</li>
<li>It is recommended that your <code>build_engine</code> script should download your engine repository's source code to a <code>source</code> subdirectory within your report repository.</li>
<li>It is recommended that your <code>build_engine</code> script should build/install your engine repository's source code to a <code>build</code> subdirectory within your report repository.</li>
<li>If your engine is <b>not</b> open-source, it may not be possible to simply download the source code via a command like <code>git clone</code>. In this case, you should write the <code>build_engine</code> script with the assumption that your engine's source code has been manually copied by the end-user into a <code>source</code> subdirectory within the report repository's top-level directory. Uponing cloning the report repository, it will be the responsibility of the user to copy your engine's source code into the correct location, assuming they have access to it. Note that you <b>absolutely should not</b> include any private information (<em>i.e.</em> software keys, private ssh keys, private source code, <em>etc.</em>) in <code>mdimechanic.yml</code> or any other file that is commited to your report repository. The <code>build</code> and <code>source</code> directories are included in the <code>.gitignore</code> file of the report; this prevents source code that is temporarily stored in those locations from being accidentally committed, unless <code>.gitignore</code> is overridden. Override <code>.gitignore</code> at your peril, and always be aware of anything you are committing to the repository.</li>
</ul>
<p>At this point, you can execute <code>mdimechanic build</code> in the top-level directory of your report repository. If this command executes successfully, great! If not, work to correct any problems with the build process before continuing to the next step.</p>
<h1><a class="anchor" id="engine_tutorial_validate"></a>
Step 6: Validate the engine build</h1>
<p>At this point, modify the <code>validate_engine</code> field in <code>mdimechanic.yml</code> so that it performs a simple test to confirm that the engine was actually built. The script should return a non-zero exit code upon failure. If your code is written in a compiled language, this can be as simple as a check to confirm the existence of the executable file: </p><div class="fragment"><div class="line">validate_engine:</div><div class="line">  - ENGINE_EXECUTABLE_PATH=&quot;build/&lt;engine_exectuable_name&gt;&quot;</div><div class="line">  - |</div><div class="line">    if test -f &quot;$ENGINE_EXECUTABLE_PATH&quot;; then</div><div class="line">      echo &quot;$ENGINE_EXECUTABLE_PATH exists&quot;</div><div class="line">    else</div><div class="line">      echo &quot;Could not find engine executable: $ENGINE_EXECUTABLE_PATH&quot;</div><div class="line">      exit 1</div><div class="line">    fi</div></div><!-- fragment --><p> If your code is written in Python, you might instead confim that your code can be imported (<em>i.e.</em> <code>python -c "import &lt;engine_name&gt;"</code>).</p>
<p>After providing a <code>validate_engine</code> script, run <code>mdimechanic report</code> in the top-level directory of your MPI-report repository. This will perform a series of tests to confirm whether your engine supports MDI correctly. The first of these tests simply runs the <code>validate_engine</code> script. Since we haven't even started implementing MDI functionality in your engine yet, it is expected that MDI Mechanic will report errors shortly after starting. After <code>mdimechanic report</code> stops (most likely throwing an error), you should find that there is a new <code>README.md</code> file in your MDI-report repository. This file contains the full report from MDI Mechanic. To properly view the file, you can either commit the file and push it to GitHub, where it can be viewed at your MDI-report repository's GitHub page, or you can install an offline markdown viewer (such as <code>grip</code>) to view it. There isn't much to see now, but hopefully you can see that there is a green <code>working</code> badge next to the step labeled "The engine builds successfully". If not, review the error messages from <code>mdimechanic report</code> to try to work out what when wrong, before moving on to the next step.</p>
<h1><a class="anchor" id="engine_tutorial_test"></a>
Step 7: Provide an example input</h1>
<p>When you run <code>mdimechanic report</code>, MDI Mechanic tries to run a series of tests to determine whether and to what extent your code supports MDI. To do this, MDI Mechanic attempts to launch your code, establish a connection between it and numerous test drivers, and then report the results. At this point in the tutorial, MDI Mechanic has no information about how to launch your code, so it can't run these tests.</p>
<p>We will now supply MDI Mechanic with everything it needs to run a calculation using your code. In <code>mdimechanic.yml</code> you will find an <code>engine_tests</code> field. This field can contain a list of scripts, each of which is intended to launch a single calculation with your code. For now, we only want to supply a single test script. The relevant part of <code>mdimechanic.yml</code> reads: </p><div class="fragment"><div class="line">engine_tests:</div><div class="line">  # Provide at least one example input that can be used to test your code&#39;s MDI functionality</div><div class="line">  - script:</div><div class="line">      - echo &quot;Insert commands to run an example calculation here&quot;</div><div class="line">      - exit 1</div></div><!-- fragment --><p> Replace the script in the <code>script</code> field here so that, when executed, it will launch a calculation using your code. This likely means that you will need to add one or more input files to your MDI-report repository, which we recommend placing in a <code>tests</code> subdirectory. Your <code>mdimechanic.yml</code> might end up looking something like this: </p><div class="fragment"><div class="line">engine_tests:</div><div class="line">  - script:</div><div class="line">      - cd tests/test1</div><div class="line">      - ../../${ENGINE_EXECUTABLE_PATH} -in test.inp</div></div><!-- fragment --><p>The exact nature of the test calculation doesn't matter very much. It should be a short calculation, since it will be run many times. The calculation might involve a simulation of a Lennard-Jones fluid, evaluation of the single-point energy of a water molecule, or some other small computatation. The most important thing about the test script is that <b>it must return a non-zero exit value if your engine exits due to an error</b>.</p>
<h1><a class="anchor" id="engine_tutorial_link"></a>
Step 8: Make the MDI Library Available to the Engine</h1>
<p>In this step, we will ensure that MDI functions can be called from your engine.</p>
<p> 
<div class="tab">
  <button class="tabbuttons cxx" onclick="revealTabContent(event, 'cxx')">C++</button>
  <button class="tabbuttons fortran" onclick="revealTabContent(event, 'fortran')">Fortran</button>
  <button class="tabbuttons python" onclick="revealTabContent(event, 'python')">Python</button>
</div>

<div class="tabcontent cxx">
 Your engine must be compiled and linked against the MDI Library. The MDI Library is released under a highly permissive BSD-3 License, and developers of MDI-enabled codes are encouraged to copy the MDI Library directly into distributions of their software. If your code uses Git for version control, you can include the MDI Library in your engine's source code repository as either a subtree (recommended) or a submodule. To incorporate a distribution of the MDI Library into your engine as a subtree, you can execute the following command in the top directory of the <em>engine's</em> Git repository (<b>not</b> in the top directory of the <em>report</em> repository): </p><div class="fragment"><div class="line">git subtree add --prefix=lib/mdi https://github.com/MolSSI-MDI/MDI_Library master --squash</div></div><!-- fragment --><p> The argument to the <code>--prefix</code> option indicates the location where the MDI Library source code will reside, and can be changed to better fit your engine's directory structure.</p>
<p>You must then modify your engine's build process to build the MDI Library and link against it. The MDI Library builds using CMake. If your engine also builds using CMake, you can simply include the MDI Library as a CMake subpackage. Otherwise, you can add a few lines to your engine's existing build scripts to execute CMake and build the MDI Library. The following lines illustrate how the MDI Library could be built, assuming that the source code for the MDI Library is located in <code>lib/mdi</code>: </p><div class="fragment"><div class="line">mkdir -p lib/mdi/build</div><div class="line">cd lib/mdi/build</div><div class="line">cmake -Dlibtype=STATIC -Dlanguage=C -DCMAKE_INSTALL_PREFIX=../install ..</div><div class="line">make</div><div class="line">make install</div></div><!-- fragment --><p> The following CMake configuration options are likely to be useful:</p><ul>
<li><b>-Dlibtype</b>: Set this to <code>STATIC</code>.</li>
<li><b>-Dlanguage</b>: Set this to the language of the code you intend to link to the MDI library. Valid options are <code>C</code>, <code>CXX</code> (for C++), <code>Fortran</code>, and <code>Python</code>.</li>
<li><b>-DCMAKE_C_COMPILER</b>: Set this to the C compiler used to build your engine (if applicable).</li>
<li><b>-DCMAKE_Fortran_COMPILER</b>: Set this to the Fortran compiler used to build your engine (if applicable).</li>
<li><b>-DCMAKE_INSTALL_PREFIX</b>: Set this to the destination directory for the installation.</li>
</ul>
<p>Finally, during the link stage of your build process, you will need to ensure that your code is linked against the MDI Library. In the case of the above example build process, the compiled static library file will be located at <code>${CMAKE_INSTALL_PREFIX}/lib/mdi</code>, and will typically be called <code>libmdi.a</code> on POSIX systems.</p>
<p> 
</div>

<div class="tabcontent fortran">
 Your engine must be compiled and linked against the MDI Library. The MDI Library is released under a highly permissive BSD-3 License, and developers of MDI-enabled codes are encouraged to copy the MDI Library directly into distributions of their software. If your code uses Git for version control, you can include the MDI Library in your engine's source code repository as either a subtree (recommended) or a submodule. To incorporate a distribution of the MDI Library into your engine as a subtree, you can execute the following command in the top directory of the <em>engine's</em> Git repository (<b>not</b> in the top directory of the <em>report</em> repository): </p><div class="fragment"><div class="line">git subtree add --prefix=lib/mdi https://github.com/MolSSI-MDI/MDI_Library master --squash</div></div><!-- fragment --><p> The argument to the <code>--prefix</code> option indicates the location where the MDI Library source code will reside, and can be changed to better fit your engine's directory structure.</p>
<p>You must then modify your engine's build process to build the MDI Library and link against it. The MDI Library builds using CMake. If your engine also builds using CMake, you can simply include the MDI Library as a CMake subpackage. Otherwise, you can add a few lines to your engine's existing build scripts to execute CMake and build the MDI Library. The following lines illustrate how the MDI Library could be built, assuming that the source code for the MDI Library is located in <code>lib/mdi</code>: </p><div class="fragment"><div class="line">mkdir -p lib/mdi/build</div><div class="line">cd lib/mdi/build</div><div class="line">cmake -Dlibtype=STATIC -Dlanguage=Fortran -DCMAKE_INSTALL_PREFIX=../install ..</div><div class="line">make</div><div class="line">make install</div></div><!-- fragment --><p> The following CMake configuration options are likely to be useful:</p><ul>
<li><b>-Dlibtype</b>: Set this to <code>STATIC</code>.</li>
<li><b>-Dlanguage</b>: Set this to the language of the code you intend to link to the MDI library. Valid options are <code>C</code>, <code>CXX</code> (for C++), <code>Fortran</code>, and <code>Python</code>.</li>
<li><b>-DCMAKE_C_COMPILER</b>: Set this to the C compiler used to build your engine (if applicable).</li>
<li><b>-DCMAKE_Fortran_COMPILER</b>: Set this to the Fortran compiler used to build your engine (if applicable).</li>
<li><b>-DCMAKE_INSTALL_PREFIX</b>: Set this to the destination directory for the installation.</li>
</ul>
<p>Finally, during the link stage of your build process, you will need to ensure that your code is linked against the MDI Library. In the case of the above example build process, the compiled static library file will be located at <code>${CMAKE_INSTALL_PREFIX}/lib/mdi</code>, and will typically be called <code>libmdi.a</code> on POSIX systems.</p>
<p> 
</div>

<div class="tabcontent python">
 First, install the MDI Library during the <code>build_image</code> step in <code>mdimechanic.yml</code>. This can be done trivially using <code>pip</code> (<em>e.g.</em> <code>pip install pymdi</code>). Your engine can then import the MDI Library where needed (<em>e.g.</em> <code>import mdi</code>).  
</div>
</p>
<h1><a class="anchor" id="engine_tutorial_input"></a>
Step 9: Support User Input of the MDI Options</h1>
<p>Your code should allow users to set certain MDI parameters at runtime. Typically, end-users should be able to set these parameters through the use of a <code>-mdi</code> command-line option when your engine is launched. In this case, the user should be able to launch your code by doing something along the lines of: </p><div class="fragment"><div class="line">engine_exectable -mdi &quot;-name engine -role ENGINE -method TCP -hostname localhost -port 8021&quot;</div></div><!-- fragment --><p> The details of how you read this command-line option are beyond the scope of this tutorial, but should conform to whatever existing method you use to read command-line options. The argument to the <code>-mdi</code> command-line option should be represented as a <code>char*</code> in C++, a <code>CHARACTER</code> array in Fortran, and a <code>String</code> in Python. Subsequent steps in this tutorial will assume that you have named the corresponding variable <code>mdi_options</code>.</p>
<p>We understand that some codes prefer to eschew command-line options where possible. If it is preferable not to introduce support for a <code>-mdi</code> command-line option, ensure that there is some other mechanism for the user to provide the MDI parameters at runtime.</p>
<h1><a class="anchor" id="engine_tutorial_init"></a>
Step 10: Initialize the MDI Library</h1>
<p>Your code must initialize the MDI Library by calling the <code><a class="el" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911" title="Initialize communication through the MDI library.">MDI_Init()</a></code> function. This is a straightforward process, but there are a couple of important details to keep in mind if you are using both MDI and the Message Passing Interface (MPI):</p><ul>
<li>If your code uses MPI, you should call <code><a class="el" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911" title="Initialize communication through the MDI library.">MDI_Init()</a></code> after the call to <code>MPI_Init()</code> (or <code>MPI_Init_thread()</code>, if applicable). Aside from the restriction, <code><a class="el" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911" title="Initialize communication through the MDI library.">MDI_Init()</a></code> should be called as early in your code as possible. It is a best practice to call <code><a class="el" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911" title="Initialize communication through the MDI library.">MDI_Init()</a></code> immediately after calling <code>MPI_Init()</code>. Calling MPI functions (other than <code>MPI_Init()</code> or <code>MPI_Init_thread()</code>) before calling <code><a class="el" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911" title="Initialize communication through the MDI library.">MDI_Init()</a></code> can lead to bugs.</li>
<li>Immediately following the call to <code><a class="el" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911" title="Initialize communication through the MDI library.">MDI_Init()</a></code>, the <code><a class="el" href="mdi_8c.html#a1792db6705a7032640af46d5b05d23f4" title="Obtain the MPI communicator that spans the single code corresponding to the calling rank.">MDI_MPI_get_world_comm()</a></code> function should be called. This function accepts a pointer to an MPI communicator as its only argument. Upon return, this pointer will point to an MPI intra-communicator that spans all ranks associated with your engine. This intra-communicator should be used whenever you would otherwise use <code>MPI_COMM_WORLD</code>. You should <b>never</b> perform MPI operations involving <code>MPI_COMM_WORLD</code> in an MDI-enabled code, as <code>MPI_COMM_WORLD</code> will in certain contexts span ranks that are not associated with your engine, but which are instead associated with the driver or other engines.</li>
</ul>
<p>The following code snippets provide a guide to correctly initializing MDI and MPI together in C++, Fortran, and Python.</p>
<p> 
<div class="tab">
  <button class="tabbuttons cxx" onclick="revealTabContent(event, 'cxx')">C++</button>
  <button class="tabbuttons fortran" onclick="revealTabContent(event, 'fortran')">Fortran</button>
  <button class="tabbuttons python" onclick="revealTabContent(event, 'python')">Python</button>
</div>

<div class="tabcontent cxx">
</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;mpi.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;mdi.h&quot;</span></div><div class="line"> </div><div class="line"><span class="comment">/* User-selected options for the MDI Library</span></div><div class="line"><span class="comment">   This should be obtained at runtime from a &quot;-mdi&quot; command-line option */</span></div><div class="line"><span class="keywordtype">char</span> *mdi_options;</div><div class="line"> </div><div class="line"><span class="comment">/* MPI intra-communicator for all processes running this code</span></div><div class="line"><span class="comment">   It should be set to MPI_COMM_WORLD prior to the call to MDI_Init(), as shown below</span></div><div class="line"><span class="comment">   Afterwards, you should ALWAYS use this variable instead of MPI_COMM_WORLD */</span></div><div class="line">MPI_Comm world_comm;</div><div class="line"> </div><div class="line"><span class="comment">/* Pointer to world_comm */</span></div><div class="line">MPI_Comm *world_comm_ptr;</div><div class="line"> </div><div class="line"><span class="comment">/* MDI communicator used to communicate with the driver */</span></div><div class="line">MDI_Comm mdi_comm = <a class="code" href="mdi_8c.html#a01e277b0239a7304055c883adb759280">MDI_COMM_NULL</a>;</div><div class="line"> </div><div class="line"><span class="comment">/* Rank of this process in the MDI-created intra-communicator */</span></div><div class="line"><span class="keywordtype">int</span> myrank = 0;</div><div class="line"> </div><div class="line"><span class="comment">/* Function to initialize both MPI and MDI */</span></div><div class="line">initialize(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line"> </div><div class="line">  <span class="comment">/* If using MPI, it should be initialized before MDI */</span></div><div class="line">  MPI_Init(&amp;argc, &amp;argv);</div><div class="line"> </div><div class="line">  <span class="comment">/* MDI should be initialized immediately after MPI */</span></div><div class="line">  <a class="code" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911">MDI_Init</a>(&amp;argc, &amp;argv);</div><div class="line">  <a class="code" href="mdi_8c.html#a1792db6705a7032640af46d5b05d23f4">MDI_MPI_get_world_comm</a>(world_comm_ptr);</div><div class="line">  <span class="comment">/* Following this point, *world_comm_ptr should be used whenever you would otherwise have used MPI_COMM_WORLD */</span></div><div class="line"> </div><div class="line">  <span class="comment">/* Get the rank of this process, within the MDI-created intra-communicator */</span></div><div class="line">  MPI_Comm_rank(*world_comm_ptr, my_rank);</div><div class="line"> </div><div class="line">  <span class="comment">/* Accept a connection from an external driver */</span></div><div class="line">  <span class="keywordflow">if</span> ( my_rank == 0 ) {</div><div class="line">    <a class="code" href="mdi_8c.html#a21a41738e9b43ab70c977f8ce63c0957">MDI_Accept_communicator</a>(&amp;mdi_comm);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>After implementing the call to <code><a class="el" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911" title="Initialize communication through the MDI library.">MDI_Init()</a></code>, you should recompile the code to confirm that your executable is linked to the MPI Library.</p>
<p> 
</div>

<div class="tabcontent fortran">
 </p><div class="fragment"><div class="line"><span class="keyword">SUBROUTINE </span>initialize ( mdi_options, world_comm, my_rank, mdi_comm )</div><div class="line">    <span class="keywordtype">USE </span>mpi,               <span class="keywordtype">ONLY</span> : mpi_comm_world</div><div class="line">    <span class="keywordtype">USE </span>mdi,               <span class="keywordtype">ONLY</span> : mdi_init, mdi_comm_null</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! User-selected options for the MDI Library</span></div><div class="line">    <span class="comment">! This should be obtained at runtime from a &quot;-mdi&quot; command-line option</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">CHARACTER(len=1024)</span>, <span class="keywordtype">INTENT(IN)</span>, <span class="keywordtype">OPTIONAL</span> :: mdi_options</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! MPI intra-communicator for all processes running this code</span></div><div class="line">    <span class="comment">! It should be set to MPI_COMM_WORLD prior to the call to MDI_Init(), as shown below</span></div><div class="line">    <span class="comment">! Afterwards, you should ALWAYS use this variable instead of MPI_COMM_WORLD</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">INTEGER</span>, <span class="keywordtype">INTENT(INOUT)</span> :: world_comm</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! Rank of this process within the MDI-created intra-communicator</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">INTEGER</span>, <span class="keywordtype">INTENT(OUT)</span> :: my_rank</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! MDI communicator, obtained from MDI_Accept_communicator</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">INTEGER</span>, <span class="keywordtype">INTENT(OUT)</span> :: mdi_comm</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! Error flag used in MDI calls</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">INTEGER</span> :: ierr</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! If using MPI, it should be initialized before MDI</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keyword">CALL </span>mpi_init(ierr)</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! MDI should be initialized immediately after MPI</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordflow">IF</span> ( <span class="keyword">PRESENT</span>(mdi_options) ) <span class="keywordflow">THEN</span></div><div class="line">        <span class="keyword">CALL </span>mdi_init(mdi_options, ierr)</div><div class="line">    <span class="keyword">CALL </span>mdi_mpi_get_world_comm(world_comm)</div><div class="line"><span class="keywordflow">    END IF</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! Following this point, world_comm should be used whenever you would otherwise have used MPI_COMM_WORLD</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! Get the rank of this process, within the MDI-created intra-communicator</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keyword">CALL </span>mpi_comm_rank(world_comm, my_rank, ierr)</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! Accept a connection from an external driver</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordflow">IF</span> ( my_rank .eq. 0 ) <span class="keywordflow">THEN</span></div><div class="line">        <span class="keyword">CALL </span>mdi_accept_communicator( mdi_comm, ierr )</div><div class="line"><span class="keywordflow">    END IF</span></div><div class="line"><span class="keyword">END SUBROUTINE </span>initialize</div></div><!-- fragment --><p>After implementing the call to <code><a class="el" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911" title="Initialize communication through the MDI library.">MDI_Init()</a></code>, you should recompile the code to confirm that your executable is linked to the MPI Library.</p>
<p> 
</div>

<div class="tabcontent python">
</p>
<div class="fragment"><div class="line"><span class="comment"># Import the MDI Library</span></div><div class="line"><span class="keyword">import</span> mdi</div><div class="line"> </div><div class="line"><span class="comment"># Attempt to import mpi4py</span></div><div class="line"><span class="keywordflow">try</span>:</div><div class="line">    <span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</div><div class="line">    use_mpi4py = <span class="keyword">True</span></div><div class="line"><span class="keywordflow">except</span> ImportError:</div><div class="line">    use_mpi4py = <span class="keyword">False</span></div><div class="line"> </div><div class="line"><span class="comment"># Get the command-line options for MDI</span></div><div class="line">...</div><div class="line"> </div><div class="line"><span class="comment"># Initialize MDI</span></div><div class="line">mdi.MDI_Init(mdi_options)</div><div class="line">world_comm = mdi.MDI_MPI_get_world_comm()</div><div class="line"> </div><div class="line"><span class="comment"># Get the MPI rank of this process</span></div><div class="line"><span class="keywordflow">if</span> world_comm <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div><div class="line">    my_rank = world_comm.Get_rank()</div><div class="line"><span class="keywordflow">else</span>:</div><div class="line">    my_rank = 0</div><div class="line"> </div><div class="line"><span class="comment"># Accept a connection from an external driver</span></div><div class="line"><span class="keywordflow">if</span> my_rank == 0:</div><div class="line">    mdi_comm = <a class="code" href="mdi_8c.html#a21a41738e9b43ab70c977f8ce63c0957">MDI_Accept_communicator</a>()</div></div><!-- fragment --><p> 
</div>
</p>
<h1><a class="anchor" id="engine_tutorial_comm"></a>
Step 11: Support Basic MDI Communication</h1>
<p>In this step, we are going to introduce some basic code that will finally allow external drivers to connect to your code and ask it to do useful things for them. First, identify a point in your code when it would be appropriate for the code to accept instructions (in the form of MDI commands) from an external driver. The chosen point should occur after your code has completed basic initialization operations (reading input files, doing basic system setup, calling <code><a class="el" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911" title="Initialize communication through the MDI library.">MDI_Init()</a></code>, <em>etc.</em>). It should also be practical to implement support for a reasonable number of MDI commands at whatever point you select. The <a href="https://molssi-mdi.github.io/MDI_Library/html/mdi_standard.html">MDI Standard</a> defines numerous commands that driver developers might want to send to your code. You won't need to support all of the available commands, but it is advisable to support some of the more common commands, such as commands that request or change the nuclear coordinates (<code>&lt;COORDS</code> and <code>&gt;COORDS</code>, respectively), as well as commands that request the energy (<code>&lt;ENERGY</code>) number of atoms (<code>&lt;NATOMS</code>), or (<code>&lt;FORCES</code>). Try to select a point where it will be possible to fulfill some of these requests. When in doubt, select a point that is reached early in your code's execution. This tutorial will subsequently refer to the point you have selected as the <b>MDI node</b>.</p>
<p>At the MDI node, you will need to insert some code (probably in the form of a called function) that handles the process of establishing communication with the external driver, accepting MDI commands from the driver, and responding to the commands appropriately. For the purpose of this tutorial, we will implement all of this functionality in a function called <code>run_mdi()</code>. Examples of a minimalistic <code>run_mdi()</code> function are provided below, in C++, Fortran, and Python. You can simply copy the function into your codebase and call <code>run_mdi()</code> at your MDI node.</p>
<p> 
<div class="tab">
  <button class="tabbuttons cxx" onclick="revealTabContent(event, 'cxx')">C++</button>
  <button class="tabbuttons fortran" onclick="revealTabContent(event, 'fortran')">Fortran</button>
  <button class="tabbuttons python" onclick="revealTabContent(event, 'python')">Python</button>
</div>

<div class="tabcontent cxx">
 Call this function as <code>run_mdi("@DEFAULT", my_rank, world_comm, mdi_comm)</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;mpi&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;mdi.h&quot;</span></div><div class="line"> </div><div class="line">run_mdi(<span class="keywordtype">char</span> *node_name, <span class="keywordtype">int</span> my_rank, MPI_Comm world_comm, MDI_Comm mdi_comm) {</div><div class="line"> </div><div class="line">  <span class="comment">/* Exit flag for the main MDI loop */</span></div><div class="line">  <span class="keywordtype">bool</span> exit_flag = <span class="keyword">false</span>;</div><div class="line"> </div><div class="line">  <span class="comment">/* MDI command from the driver */</span></div><div class="line">  command = <span class="keyword">new</span> <span class="keywordtype">char</span>[<a class="code" href="mdi_8c.html#ae5fcebdb64c7844358e07e880bcb15c2">MDI_COMMAND_LENGTH</a>];</div><div class="line"> </div><div class="line">  <span class="comment">/* Main MDI loop */</span></div><div class="line">  <span class="keywordflow">while</span> (not exit_flag) {</div><div class="line">    <span class="comment">/* Receive a command from the driver */</span></div><div class="line">    <span class="keywordflow">if</span> ( my_rank == 0 ) {</div><div class="line">      <a class="code" href="mdi_8c.html#a537752bd942b19cf0a2fd6adafb10a48">MDI_Recv_command</a>(command, mdi_comm);</div><div class="line">    }</div><div class="line">    MPI_Bcast(command, <a class="code" href="mdi_8c.html#ae5fcebdb64c7844358e07e880bcb15c2">MDI_COMMAND_LENGTH</a>, MPI_CHAR, 0, world_comm);</div><div class="line"> </div><div class="line">    <span class="comment">/* Confirm that this command is actually supported at this node */</span></div><div class="line">    <span class="keywordtype">int</span> command_supported = 0;</div><div class="line">    <a class="code" href="mdi_8c.html#a748099153c09f719c3f1cf5965c9a457">MDI_Check_command_exists</a>(node_name, command, <a class="code" href="mdi_8c.html#a01e277b0239a7304055c883adb759280">MDI_COMM_NULL</a>, &amp;command_supported);</div><div class="line">    <span class="keywordflow">if</span> ( command_supported != 1 ) {</div><div class="line">      <span class="comment">/* Note: Replace this with whatever error handling method your code uses */</span></div><div class="line">      MPI_Abort(world_comm, 1);</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="comment">/* Respond to the received command */</span></div><div class="line">    <span class="keywordflow">if</span> ( strcmp(command, <span class="stringliteral">&quot;EXIT&quot;</span>) == 0 ) {</div><div class="line">      exit_flag = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">      <span class="comment">/* The received command is not recognized by this engine, so exit</span></div><div class="line"><span class="comment">         Note: Replace this with whatever error handling method your code uses */</span></div><div class="line">      MPI_Abort(world_comm, 1);</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="comment">// Free any memory allocations</span></div><div class="line">  <span class="keyword">delete</span> [] command;</div><div class="line">}</div></div><!-- fragment --><p> 
</div>

<div class="tabcontent fortran">
 Call this function as <code>CALL run_mdi("@DEFAULT", my_rank, world_comm, mdi_comm)</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">SUBROUTINE </span>run_mdi( node_name, my_rank, world_comm, mdi_comm )</div><div class="line">    <span class="keywordtype">USE </span>mdi,              <span class="keywordtype">ONLY</span> : mdi_send, mdi_recv, mdi_recv_command, &amp;</div><div class="line">                                 mdi_accept_communicator, &amp;</div><div class="line">                 mdi_char, mdi_double, mdi_int, &amp;</div><div class="line">                 mdi_command_length, mdi_name_length, &amp;</div><div class="line">                 mdi_comm_null</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! MDI command from the driver</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">CHARACTER</span> :: node_name(MDI_NAME_LENGTH)</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! Rank of this process in world_comm</span></div><div class="line">    <span class="comment">! If you are not using MPI, you can set my_rank = 0</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">INTEGER</span>, <span class="keywordtype">INTENT(IN)</span> :: my_rank</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! MDI-created intra-communicator</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">INTEGER</span>, <span class="keywordtype">INTENT(IN)</span> :: world_comm</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! MDI communicator, obtained from MDI_Accept_communicator</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">INTEGER</span>, <span class="keywordtype">INTENT(IN)</span> :: mdi_comm</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! MDI command from the driver</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">CHARACTER</span>, <span class="keywordtype">ALLOCATABLE</span> :: command(:)</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! Error flag for MDI functions</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">INTEGER</span> :: ierr</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! Flag to indicate whether a received command is supported</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keywordtype">INTEGER</span> :: command_supported</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! Allocate the command array</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="keyword">ALLOCATE</span>( command(mdi_command_length) )</div><div class="line">    <span class="comment">!</span></div><div class="line">    <span class="comment">! Main MDI loop</span></div><div class="line">    <span class="comment">!</span></div><div class="line">    mdi_loop: <span class="keywordflow">DO</span></div><div class="line">        <span class="comment">!</span></div><div class="line">        <span class="comment">! Receive a command from the driver</span></div><div class="line">        <span class="comment">!</span></div><div class="line">        <span class="keywordflow">IF</span> ( my_rank .eq. 0 ) <span class="keywordflow">THEN</span></div><div class="line">            <span class="keyword">CALL </span>mdi_recv_command( command, mdi_comm, ierr )</div><div class="line">            <span class="keyword">WRITE</span>(*,*) <span class="stringliteral">&quot;MDI Engine received a command: &quot;</span>,trim(command)</div><div class="line"><span class="keywordflow">        END IF</span></div><div class="line">        <span class="comment">!</span></div><div class="line">        <span class="comment">! Broadcast the command to all ranks</span></div><div class="line">        <span class="comment">! Note: Remove this line if not using MPI</span></div><div class="line">        <span class="comment">!</span></div><div class="line">        <span class="keyword">CALL </span>mpi_bcast( header, mdi_command_length, mpi_char, 0, world_comm )</div><div class="line">        <span class="comment">!</span></div><div class="line">        <span class="comment">! Confirm that this command is actually supported at this node</span></div><div class="line">        <span class="comment">!</span></div><div class="line">        command_supported = 0;</div><div class="line">        <span class="keyword">CALL </span>mdi_check_command_exists(node_name, command, mdi_comm_null, command_supported, ierr);</div><div class="line">        <span class="keywordflow">IF</span> ( command_supported .ne. 1 ) <span class="keywordflow">THEN</span></div><div class="line">            <span class="comment">! Note: Replace this with whatever error handling method your code uses</span></div><div class="line">            <span class="keyword">CALL </span>mpi_abort(world_comm, 1);</div><div class="line"><span class="keywordflow">        END IF</span></div><div class="line">        <span class="comment">!</span></div><div class="line">        <span class="comment">! Respond to the received command</span></div><div class="line">        <span class="comment">!</span></div><div class="line">        <span class="keywordflow">SELECT CASE</span> ( trim( command ) )</div><div class="line">    <span class="keywordflow">CASE</span>( <span class="stringliteral">&quot;EXIT&quot;</span> )</div><div class="line">        <span class="keywordflow">RETURN</span></div><div class="line"><span class="keywordflow">        CASE DEFAULT</span></div><div class="line">            <span class="comment">!</span></div><div class="line">            <span class="comment">! The received command is not recognized by this engine, so exit</span></div><div class="line">            <span class="comment">! Note: Replace this with whatever error handling method your code uses</span></div><div class="line">            <span class="comment">!</span></div><div class="line">            <span class="keyword">WRITE</span>(*,*) <span class="stringliteral">&quot;MDI Engine received unrecognized command: &quot;</span>,trim(command)</div><div class="line">            <span class="keyword">CALL </span>mpi_abort(world_comm, 1);</div><div class="line"><span class="keywordflow">        END SELECT</span></div><div class="line"><span class="keywordflow">    END DO</span> mdi_loop</div><div class="line"><span class="keyword">END SUBROUTINE </span>run_mdi</div></div><!-- fragment --><p> 
</div>

<div class="tabcontent python">
</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> mdi</div><div class="line"> </div><div class="line"><span class="keyword">def </span>run_mdi(node_name, my_rank, world_comm, mdi_comm):</div><div class="line"> </div><div class="line">    exit_flag = <span class="keyword">False</span></div><div class="line"> </div><div class="line">    <span class="comment"># Main MDI loop</span></div><div class="line">    <span class="keywordflow">while</span> <span class="keywordflow">not</span> exit_flag:</div><div class="line">        <span class="comment"># Receive a command from the driver</span></div><div class="line">        <span class="keywordflow">if</span> self.my_rank == 0:</div><div class="line">            command = mdi.MDI_Recv_command(self.comm)</div><div class="line">        <span class="keywordflow">else</span>:</div><div class="line">            command = <span class="keywordtype">None</span></div><div class="line"> </div><div class="line">        <span class="comment"># Broadcast the command to all ranks, if using MPI</span></div><div class="line">        <span class="keywordflow">if</span> world_comm <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div><div class="line">            command = world_comm.bcast(command, root=0)</div><div class="line"> </div><div class="line">        <span class="comment"># Confirm that this command is actually supported at this node</span></div><div class="line">        <span class="keywordflow">if</span> <span class="keywordflow">not</span> mdi.MDI_Check_node_exists(node_name, command):</div><div class="line">            <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&#39;MDI Engine received unsupported command: &#39;</span> + str(command))</div><div class="line"> </div><div class="line">        <span class="comment"># Respond to the received command</span></div><div class="line">        <span class="keywordflow">if</span> command == <span class="stringliteral">&quot;EXIT&quot;</span>:</div><div class="line">            exit_flag = <span class="keyword">True</span></div><div class="line">        <span class="keywordflow">else</span>:</div><div class="line">            <span class="comment"># The received command is not recognized by this engine, so exit</span></div><div class="line">            <span class="comment"># Note: Replace this with whatever error handling method your code uses</span></div><div class="line">            <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&#39;MDI Engine received unrecognized command: &#39;</span> + str(command))</div></div><!-- fragment --><p> 
</div>
</p>
<h1><a class="anchor" id="engine_tutorial_register"></a>
Step 12: Register the Node and Commands</h1>
<p>MDI requires you to "register" a list of all nodes and commands your engine supports. This allows you, as an engine developer, to inform any drivers of what your code can do. MDI provides two functions that allow you to do this: <code><a class="el" href="mdi_8c.html#ae191ab5848b0c586643f63412a18dcf2" title="Register a node.">MDI_Register_node()</a></code> and <code><a class="el" href="mdi_8c.html#a6c9047a0e290090af2d8a2fc3a04d44d" title="Register a command on a specified node.">MDI_Register_command()</a></code>. The engine we have developed thus far in the tutorial only supports a single node, and that node only supports a single command. As a result, we need to call <code><a class="el" href="mdi_8c.html#ae191ab5848b0c586643f63412a18dcf2" title="Register a node.">MDI_Register_node()</a></code> once to register the <code>@DEFAULT</code> node and call <code><a class="el" href="mdi_8c.html#a6c9047a0e290090af2d8a2fc3a04d44d" title="Register a command on a specified node.">MDI_Register_command()</a></code> once to register the <code>EXIT</code> command.</p>
<p>Fortunately, this is a very simple process. The only argument to the <code><a class="el" href="mdi_8c.html#ae191ab5848b0c586643f63412a18dcf2" title="Register a node.">MDI_Register_node()</a></code> function is the name of the node, <code>@DEFAULT</code>. The <code><a class="el" href="mdi_8c.html#a6c9047a0e290090af2d8a2fc3a04d44d" title="Register a command on a specified node.">MDI_Register_command()</a></code> function accepts two arguments: the name of the node, and the name of the command that we are registering at that node, <code>EXIT</code>. In time, you may add support for additional commands at the default node, making additional calls to <code><a class="el" href="mdi_8c.html#a6c9047a0e290090af2d8a2fc3a04d44d" title="Register a command on a specified node.">MDI_Register_command()</a></code> for each newly supported command. If you add additional nodes, each node will have its own list of registered commands, which may be different from the list of commands supported at the <code>@DEFAULT</code> node.</p>
<p>For now, place the following code immediately after your engine's call to <code><a class="el" href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911" title="Initialize communication through the MDI library.">MDI_Init()</a></code>. It is important that it be called prior to the call to <code><a class="el" href="mdi_8c.html#a21a41738e9b43ab70c977f8ce63c0957" title="Accept a new MDI communicator.">MDI_Accept_communicator()</a></code>.</p>
<p> 
<div class="tab">
  <button class="tabbuttons cxx" onclick="revealTabContent(event, 'cxx')">C++</button>
  <button class="tabbuttons fortran" onclick="revealTabContent(event, 'fortran')">Fortran</button>
  <button class="tabbuttons python" onclick="revealTabContent(event, 'python')">Python</button>
</div>

<div class="tabcontent cxx">
</p>
<div class="fragment"><div class="line"><span class="comment">/* Register all supported commands and nodes */</span></div><div class="line"><a class="code" href="mdi_8c.html#ae191ab5848b0c586643f63412a18dcf2">MDI_Register_node</a>(<span class="stringliteral">&quot;@DEFAULT&quot;</span>);</div><div class="line"><a class="code" href="mdi_8c.html#a6c9047a0e290090af2d8a2fc3a04d44d">MDI_Register_command</a>(<span class="stringliteral">&quot;@DEFAULT&quot;</span>, <span class="stringliteral">&quot;EXIT&quot;</span>);</div></div><!-- fragment --><p> 
</div>

<div class="tabcontent fortran">
</p>
<div class="fragment"><div class="line"><span class="comment">! Register all supported commands and nodes</span></div><div class="line"><span class="comment">CALL MDI_Register_node(&quot;@DEFAULT&quot;, ierr);</span></div><div class="line"><span class="comment">CALL MDI_Register_command(&quot;@DEFAULT&quot;, &quot;EXIT&quot;, ierr);</span></div></div><!-- fragment --><p> 
</div>

<div class="tabcontent python">
</p>
<div class="fragment"><div class="line"><span class="comment"># Register all supported commands and nodes</span></div><div class="line">mdi.MDI_Register_node(<span class="stringliteral">&quot;@DEFAULT&quot;</span>)</div><div class="line">mdi.MDI_Register_command(<span class="stringliteral">&quot;@DEFAULT&quot;</span>, <span class="stringliteral">&quot;EXIT&quot;</span>)</div></div><!-- fragment --><p> 
</div>
</p>
<h1><a class="anchor" id="engine_tutorial_commands"></a>
Step 13: Add Support for Additional Commands</h1>
<p>It may not look like much yet, but you have now established a basic MDI interface! If you generate a new report by typing <code>mdimechanic report</code> at the command line, MDI Mechanic should confirm that your engine passes all of the "Basic Functionality Tests". If your engine is still failing that test, you should return to the previous steps of this tutorial to determine what went wrong.</p>
<p>Assuming that your MDI interface is functioning as expected, you can now begin the process of implementing support for more commands. Whenever you want to add support for a new command, you will need to do the following:</p><ol type="1">
<li>Add code to the "Main MDI loop" in <code>run_mdi()</code> that will respond appropriately to the new command.</li>
<li>Add a call to <code><a class="el" href="mdi_8c.html#a6c9047a0e290090af2d8a2fc3a04d44d" title="Register a command on a specified node.">MDI_Register_command()</a></code> to register support for that command.</li>
</ol>
<p>Examine the commands specified by the <a href="https://molssi-mdi.github.io/MDI_Library/html/mdi_standard.html">MDI Standard</a>, and implement support for the ones that seem relevant for your engine. Each command in the MDI Standard describes exactly how the engine is expected to respond. Often, the engine is expected to either send or receive information to/from the driver. This is accomplished using the <code><a class="el" href="mdi_8c.html#a7bebce6d5fa91ee99a34fdcc5dcaedea" title="Send data through the MDI connection.">MDI_Send()</a></code> and <code><a class="el" href="mdi_8c.html#ab73f32323a155011fcc184866215ba03" title="Receive data through the MDI connection.">MDI_Recv()</a></code> functions, respectively.</p>
<p>If you are using MPI, you should be aware that all MDI-based communication must take place through <code>rank 0</code>. Only <code>rank 0</code> should call <code>MPI_Send()</code>, <code>MPI_Recv()</code>, and <code>MPI_Recv_Command()</code>. Depending on how you have distributed data structures across ranks, you may need to do <code>MPI_Gather()</code> or similar operations to collect the data onto <code>rank 0</code> before calling <code><a class="el" href="mdi_8c.html#a7bebce6d5fa91ee99a34fdcc5dcaedea" title="Send data through the MDI connection.">MDI_Send()</a></code>. Likewise, you may need to do <code>MPI_Scatter()</code> or similar operations to correctly distribute data after calling <code><a class="el" href="mdi_8c.html#ab73f32323a155011fcc184866215ba03" title="Receive data through the MDI connection.">MDI_Recv()</a></code>.</p>
<h1><a class="anchor" id="engine_tutorial_nodes"></a>
Step 14: Add Support for Additional Nodes</h1>
<p>Whenever you add a new node, you must also add a call to <code><a class="el" href="mdi_8c.html#ae191ab5848b0c586643f63412a18dcf2" title="Register a node.">MDI_Register_node()</a></code> to register support for that node. Commands are registered separately for each node, so any commands that are supported at the new node must be registered for it. For example, if you implement five nodes, and each of them supports the <code>EXIT</code> command, you will need to call the <code><a class="el" href="mdi_8c.html#a6c9047a0e290090af2d8a2fc3a04d44d" title="Register a command on a specified node.">MDI_Register_command()</a></code> function five times, each time with a different node as the first argument and with <code>EXIT</code> as the second argument. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="amdi_8c_html_a1792db6705a7032640af46d5b05d23f4"><div class="ttname"><a href="mdi_8c.html#a1792db6705a7032640af46d5b05d23f4">MDI_MPI_get_world_comm</a></div><div class="ttdeci">int MDI_MPI_get_world_comm(void *world_comm)</div><div class="ttdoc">Obtain the MPI communicator that spans the single code corresponding to the calling rank.</div><div class="ttdef"><b>Definition:</b> mdi.c:1565</div></div>
<div class="ttc" id="amdi_8c_html_a01e277b0239a7304055c883adb759280"><div class="ttname"><a href="mdi_8c.html#a01e277b0239a7304055c883adb759280">MDI_COMM_NULL</a></div><div class="ttdeci">const MDI_Comm MDI_COMM_NULL</div><div class="ttdoc">value of a null communicator</div><div class="ttdef"><b>Definition:</b> mdi.c:55</div></div>
<div class="ttc" id="amdi_8c_html_ae191ab5848b0c586643f63412a18dcf2"><div class="ttname"><a href="mdi_8c.html#ae191ab5848b0c586643f63412a18dcf2">MDI_Register_node</a></div><div class="ttdeci">int MDI_Register_node(const char *node_name)</div><div class="ttdoc">Register a node.</div><div class="ttdef"><b>Definition:</b> mdi.c:880</div></div>
<div class="ttc" id="amdi_8c_html_ae5fcebdb64c7844358e07e880bcb15c2"><div class="ttname"><a href="mdi_8c.html#ae5fcebdb64c7844358e07e880bcb15c2">MDI_COMMAND_LENGTH</a></div><div class="ttdeci">const int MDI_COMMAND_LENGTH</div><div class="ttdoc">length of an MDI command in characters</div><div class="ttdef"><b>Definition:</b> mdi.c:46</div></div>
<div class="ttc" id="amdi_8c_html_a9f26d9f67413c6c194a2f5e4bd69b911"><div class="ttname"><a href="mdi_8c.html#a9f26d9f67413c6c194a2f5e4bd69b911">MDI_Init</a></div><div class="ttdeci">int MDI_Init(int *argc, char ***argv)</div><div class="ttdoc">Initialize communication through the MDI library.</div><div class="ttdef"><b>Definition:</b> mdi.c:112</div></div>
<div class="ttc" id="amdi_8c_html_a748099153c09f719c3f1cf5965c9a457"><div class="ttname"><a href="mdi_8c.html#a748099153c09f719c3f1cf5965c9a457">MDI_Check_command_exists</a></div><div class="ttdeci">int MDI_Check_command_exists(const char *node_name, const char *command_name, MDI_Comm comm, int *flag)</div><div class="ttdoc">Check whether a command is supported on specified node on a specified engine.</div><div class="ttdef"><b>Definition:</b> mdi.c:1127</div></div>
<div class="ttc" id="amdi_8c_html_a21a41738e9b43ab70c977f8ce63c0957"><div class="ttname"><a href="mdi_8c.html#a21a41738e9b43ab70c977f8ce63c0957">MDI_Accept_communicator</a></div><div class="ttdeci">MDI_Comm MDI_Accept_communicator(MDI_Comm *comm)</div><div class="ttdoc">Accept a new MDI communicator.</div><div class="ttdef"><b>Definition:</b> mdi.c:208</div></div>
<div class="ttc" id="amdi_8c_html_a537752bd942b19cf0a2fd6adafb10a48"><div class="ttname"><a href="mdi_8c.html#a537752bd942b19cf0a2fd6adafb10a48">MDI_Recv_command</a></div><div class="ttdeci">int MDI_Recv_command(char *buf, MDI_Comm comm)</div><div class="ttdoc">Receive a command of length MDI_COMMAND_LENGTH through the MDI connection.</div><div class="ttdef"><b>Definition:</b> mdi.c:329</div></div>
<div class="ttc" id="amdi_8c_html_a6c9047a0e290090af2d8a2fc3a04d44d"><div class="ttname"><a href="mdi_8c.html#a6c9047a0e290090af2d8a2fc3a04d44d">MDI_Register_command</a></div><div class="ttdeci">int MDI_Register_command(const char *node_name, const char *command_name)</div><div class="ttdoc">Register a command on a specified node.</div><div class="ttdef"><b>Definition:</b> mdi.c:1082</div></div>
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
